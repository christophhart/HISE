/*  ===========================================================================
 *
 *   This file is part of HISE.
 *   Copyright 2016 Christoph Hart
 *
 *   HISE is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   HISE is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with HISE.  If not, see <http://www.gnu.org/licenses/>.
 *
 *   Commercial licenses for using HISE in an closed source project are
 *   available on request. Please visit the project's website to get more
 *   information about commercial licensing:
 *
 *   http://www.hise.audio/
 *
 *   HISE is based on the JUCE library,
 *   which also must be licensed for commercial applications:
 *
 *   http://www.juce.com
 *
 *   ===========================================================================
 */

namespace scriptnode
{
using namespace juce;
using namespace hise;

namespace ScriptnodeIcons
{
	

static const unsigned char signalIcon[] = { 110,109,244,229,47,68,184,230,154,68,108,205,140,56,68,184,230,154,68,108,244,229,47,68,205,196,161,68,108,244,229,47,68,174,119,167,68,108,119,118,56,68,174,119,167,68,108,160,202,45,68,236,1,176,68,108,184,30,35,68,174,119,167,68,108,59,175,43,68,174,
119,167,68,108,59,175,43,68,205,196,161,68,108,115,8,35,68,184,230,154,68,108,59,175,43,68,184,230,154,68,108,59,175,43,68,195,253,153,68,108,244,229,47,68,195,253,153,68,108,244,229,47,68,184,230,154,68,99,109,145,101,27,68,215,179,160,68,108,145,101,
27,68,195,253,153,68,108,217,46,23,68,195,253,153,68,108,217,46,23,68,215,179,160,68,108,172,236,13,68,215,179,160,68,108,217,46,23,68,82,168,167,68,108,217,46,23,68,102,222,175,68,108,145,101,27,68,102,222,175,68,108,145,101,27,68,82,168,167,68,108,
174,167,36,68,215,179,160,68,108,145,101,27,68,215,179,160,68,99,101,0,0 };

	static const unsigned char zoomIn[] = { 110,109,125,159,52,67,90,68,76,67,98,47,189,27,67,154,89,94,67,244,253,246,66,154,153,102,67,90,36,185,66,119,222,96,67,98,176,242,58,66,66,96,88,67,193,202,1,65,211,141,49,67,37,6,145,63,74,236,1,67,98,143,194,157,192,154,25,177,66,61,10,91,65,6,1,50,
66,45,50,67,66,100,59,161,65,98,248,83,134,66,115,104,237,64,18,131,178,66,231,251,169,62,63,181,223,66,188,116,19,60,98,14,237,224,66,111,18,3,59,221,36,226,66,111,18,131,186,172,92,227,66,0,0,0,0,98,12,34,27,67,57,180,72,62,37,102,67,67,76,55,197,65,
92,111,86,67,205,76,120,66,98,96,165,103,67,236,209,191,66,211,77,102,67,96,69,10,67,160,186,82,67,184,94,43,67,108,238,236,148,67,250,62,129,67,108,172,44,133,67,27,255,144,67,108,125,159,52,67,90,68,76,67,99,109,129,21,226,66,2,43,231,65,98,141,215,
183,66,207,247,231,65,82,248,141,66,51,51,21,66,59,95,94,66,41,220,78,66,98,141,151,237,65,145,237,151,66,195,245,170,65,88,249,233,66,20,46,20,66,72,193,21,67,98,109,103,83,66,199,203,54,67,203,225,182,66,6,97,75,67,133,203,0,67,188,116,68,67,98,190,
255,34,67,53,30,62,67,100,219,63,67,88,249,32,67,236,241,68,67,39,241,250,66,98,6,193,72,67,186,201,197,66,215,3,63,67,18,131,141,66,76,151,43,67,182,243,80,66,98,195,53,28,67,193,74,22,66,66,64,7,67,43,135,232,65,94,186,227,66,27,47,231,65,98,20,46,
227,66,2,43,231,65,203,161,226,66,2,43,231,65,129,21,226,66,2,43,231,65,99,109,246,72,2,67,61,138,198,66,108,113,29,49,67,61,138,198,66,108,113,29,49,67,143,66,3,67,108,246,72,2,67,143,66,3,67,108,246,72,2,67,160,154,49,67,108,61,74,198,66,160,154,49,
67,108,61,74,198,66,143,66,3,67,108,119,190,81,66,143,66,3,67,108,119,190,81,66,61,138,198,66,108,61,74,198,66,61,138,198,66,108,61,74,198,66,51,179,83,66,108,246,72,2,67,51,179,83,66,108,246,72,2,67,61,138,198,66,99,101,0,0 };

	static const unsigned char zoomOriginal[] = { 110,109,125,159,52,67,90,68,76,67,98,47,189,27,67,154,89,94,67,244,253,246,66,154,153,102,67,90,36,185,66,119,222,96,67,98,176,242,58,66,66,96,88,67,193,202,1,65,211,141,49,67,37,6,145,63,74,236,1,67,98,143,194,157,192,154,25,177,66,61,10,91,65,6,1,50,
66,45,50,67,66,100,59,161,65,98,248,83,134,66,115,104,237,64,18,131,178,66,231,251,169,62,63,181,223,66,188,116,19,60,98,14,237,224,66,111,18,3,59,221,36,226,66,111,18,131,186,172,92,227,66,0,0,0,0,98,12,34,27,67,57,180,72,62,37,102,67,67,76,55,197,65,
92,111,86,67,205,76,120,66,98,96,165,103,67,236,209,191,66,211,77,102,67,96,69,10,67,160,186,82,67,184,94,43,67,108,238,236,148,67,250,62,129,67,108,172,44,133,67,27,255,144,67,108,125,159,52,67,90,68,76,67,99,109,129,21,226,66,2,43,231,65,98,141,215,
183,66,207,247,231,65,82,248,141,66,51,51,21,66,59,95,94,66,41,220,78,66,98,141,151,237,65,145,237,151,66,195,245,170,65,88,249,233,66,20,46,20,66,72,193,21,67,98,109,103,83,66,199,203,54,67,203,225,182,66,6,97,75,67,133,203,0,67,188,116,68,67,98,190,
255,34,67,53,30,62,67,100,219,63,67,88,249,32,67,236,241,68,67,39,241,250,66,98,6,193,72,67,186,201,197,66,215,3,63,67,18,131,141,66,76,151,43,67,182,243,80,66,98,195,53,28,67,193,74,22,66,66,64,7,67,43,135,232,65,94,186,227,66,27,47,231,65,98,20,46,
227,66,2,43,231,65,203,161,226,66,2,43,231,65,129,21,226,66,2,43,231,65,99,101,0,0 };

	static const unsigned char zoomOut[] = { 110,109,125,159,52,67,90,68,76,67,98,47,189,27,67,154,89,94,67,244,253,246,66,154,153,102,67,90,36,185,66,119,222,96,67,98,176,242,58,66,66,96,88,67,193,202,1,65,211,141,49,67,37,6,145,63,74,236,1,67,98,143,194,157,192,154,25,177,66,61,10,91,65,6,1,50,
66,45,50,67,66,100,59,161,65,98,248,83,134,66,115,104,237,64,18,131,178,66,231,251,169,62,63,181,223,66,188,116,19,60,98,14,237,224,66,111,18,3,59,221,36,226,66,111,18,131,186,172,92,227,66,0,0,0,0,98,12,34,27,67,57,180,72,62,37,102,67,67,76,55,197,65,
92,111,86,67,205,76,120,66,98,96,165,103,67,236,209,191,66,211,77,102,67,96,69,10,67,160,186,82,67,184,94,43,67,108,238,236,148,67,250,62,129,67,108,172,44,133,67,27,255,144,67,108,125,159,52,67,90,68,76,67,99,109,129,21,226,66,2,43,231,65,98,141,215,
183,66,207,247,231,65,82,248,141,66,51,51,21,66,59,95,94,66,41,220,78,66,98,141,151,237,65,145,237,151,66,195,245,170,65,88,249,233,66,20,46,20,66,72,193,21,67,98,109,103,83,66,199,203,54,67,203,225,182,66,6,97,75,67,133,203,0,67,188,116,68,67,98,190,
255,34,67,53,30,62,67,100,219,63,67,88,249,32,67,236,241,68,67,39,241,250,66,98,6,193,72,67,186,201,197,66,215,3,63,67,18,131,141,66,76,151,43,67,182,243,80,66,98,195,53,28,67,193,74,22,66,66,64,7,67,43,135,232,65,94,186,227,66,27,47,231,65,98,20,46,
227,66,2,43,231,65,203,161,226,66,2,43,231,65,129,21,226,66,2,43,231,65,99,109,221,196,39,67,190,255,7,67,108,246,40,129,66,190,255,7,67,108,246,40,129,66,51,115,204,66,108,221,196,39,67,51,115,204,66,108,221,196,39,67,190,255,7,67,99,101,0,0 };

	static const unsigned char zoomSelection[] = { 110,109,16,152,150,66,135,214,171,67,108,16,152,150,66,39,225,183,67,98,150,3,131,66,39,225,183,67,47,221,94,66,106,236,183,67,57,180,55,66,197,224,183,67,98,80,141,214,65,203,193,183,67,80,141,5,65,137,65,177,67,96,229,16,64,84,179,167,67,98,96,229,
16,64,84,179,167,67,82,184,201,65,205,12,164,67,82,184,201,65,205,12,164,67,98,106,188,201,65,113,13,164,67,119,190,201,65,20,14,164,67,143,194,201,65,184,14,164,67,98,45,178,224,65,182,131,168,67,201,118,19,66,78,210,171,67,135,22,58,66,135,214,171,
67,108,16,152,150,66,135,214,171,67,99,109,203,161,43,67,39,225,183,67,108,18,195,198,66,39,225,183,67,108,18,195,198,66,135,214,171,67,108,203,161,43,67,135,214,171,67,108,203,161,43,67,39,225,183,67,99,109,199,251,133,67,39,225,183,67,108,76,183,67,
67,39,225,183,67,108,76,183,67,67,135,214,171,67,108,199,251,133,67,135,214,171,67,108,199,251,133,67,39,225,183,67,99,109,233,22,184,67,117,195,171,67,98,57,36,180,67,61,250,178,67,51,51,172,67,252,217,183,67,82,184,163,67,39,225,183,67,98,82,184,163,
67,39,225,183,67,135,6,146,67,39,225,183,67,135,6,146,67,39,225,183,67,108,135,6,146,67,135,214,171,67,98,141,247,151,67,135,214,171,67,180,232,157,67,123,228,171,67,186,217,163,67,70,214,171,67,98,117,195,167,67,70,198,171,67,240,135,171,67,201,134,
169,67,63,117,173,67,35,27,166,67,108,168,134,173,67,166,251,165,67,98,8,12,177,67,213,232,167,67,137,145,180,67,37,214,169,67,233,22,184,67,117,195,171,67,99,109,78,130,91,67,37,102,117,67,98,0,160,66,67,178,189,131,67,12,98,34,67,145,221,135,67,254,
116,3,67,33,0,133,67,98,250,62,171,66,229,192,128,67,250,254,59,66,158,175,90,67,117,19,32,66,211,13,43,67,98,242,210,7,66,86,174,1,67,211,77,82,66,150,67,171,66,59,95,175,66,221,36,117,66,98,29,26,212,66,51,51,66,66,90,36,0,67,35,219,37,66,113,189,22,
67,92,143,36,66,98,88,89,23,67,55,137,36,66,63,245,23,67,37,134,36,66,104,145,24,67,43,135,36,66,98,221,4,66,67,217,78,37,66,246,72,106,67,104,145,131,66,45,82,125,67,252,105,206,66,98,57,68,135,67,193,10,9,67,82,152,134,67,43,103,51,67,113,157,121,67,
131,128,84,67,108,86,94,168,67,190,207,149,67,108,20,158,152,67,0,144,165,67,108,78,130,91,67,37,102,117,67,99,109,213,232,186,67,20,46,157,67,108,20,222,174,67,20,46,157,67,108,20,222,174,67,166,27,114,67,108,213,232,186,67,166,27,114,67,108,213,232,
186,67,20,46,157,67,99,109,127,106,193,65,227,229,153,67,108,201,118,190,61,227,229,153,67,108,201,118,190,61,133,139,107,67,108,127,106,193,65,133,139,107,67,108,127,106,193,65,227,229,153,67,99,109,145,237,23,67,86,14,140,66,98,217,206,2,67,137,65,
140,66,244,189,219,66,47,221,156,66,63,245,188,66,39,177,185,66,98,133,43,137,66,39,49,234,66,37,6,113,66,53,30,30,67,47,221,151,66,18,227,62,67,98,219,121,183,66,145,237,95,67,182,83,2,67,143,130,116,67,86,174,39,67,135,150,109,67,98,143,226,73,67,190,
63,103,67,53,190,102,67,225,26,74,67,188,212,107,67,29,154,38,67,98,215,163,111,67,102,6,12,67,168,230,101,67,168,198,223,66,94,122,82,67,238,188,186,66,98,147,24,67,67,115,104,157,66,84,35,46,67,96,101,140,66,0,192,24,67,217,14,140,66,98,219,121,24,
67,86,14,140,66,182,51,24,67,86,14,140,66,145,237,23,67,86,14,140,66,99,109,213,232,186,67,102,6,90,67,108,20,222,174,67,102,6,90,67,108,20,222,174,67,227,197,17,67,108,213,232,186,67,227,197,17,67,108,213,232,186,67,102,6,90,67,99,109,127,106,193,65,
4,118,83,67,108,201,118,190,61,4,118,83,67,108,201,118,190,61,195,53,11,67,108,127,106,193,65,195,53,11,67,108,127,106,193,65,4,118,83,67,99,109,213,232,186,67,72,97,243,66,108,20,222,174,67,72,97,243,66,108,20,222,174,67,131,192,69,66,108,213,232,186,
67,131,192,69,66,108,213,232,186,67,72,97,243,66,99,109,127,106,193,65,131,64,230,66,108,201,118,190,61,131,64,230,66,98,201,118,190,61,92,15,184,66,70,182,243,189,47,221,137,66,240,167,198,61,23,89,55,66,98,252,169,241,61,74,140,48,66,104,145,173,62,
250,126,38,66,104,145,173,62,250,126,38,66,98,104,145,173,62,250,126,38,66,16,88,194,65,219,121,48,66,16,88,194,65,219,121,48,66,98,162,69,194,65,35,219,48,66,51,51,194,65,106,60,49,66,197,32,194,65,178,157,49,66,98,252,169,193,65,229,80,52,66,152,110,
193,65,31,5,55,66,127,106,193,65,100,187,57,66,108,127,106,193,65,131,64,230,66,99,109,82,184,163,67,111,18,131,59,98,195,133,175,67,158,239,167,61,178,189,186,67,18,131,156,65,82,232,186,67,23,89,55,66,98,180,232,186,67,86,142,56,66,213,232,186,67,250,
126,57,66,213,232,186,67,250,126,57,66,108,20,222,174,67,223,207,57,66,98,55,217,174,67,8,44,11,66,176,210,169,67,178,157,193,65,43,199,163,67,70,182,192,65,98,43,199,163,67,70,182,192,65,111,146,154,67,57,180,192,65,111,146,154,67,57,180,192,65,108,
111,146,154,67,111,18,131,59,98,27,159,157,67,111,18,131,59,166,171,160,67,166,155,196,187,82,184,163,67,111,18,131,59,99,109,174,199,184,66,57,180,192,65,98,119,254,153,66,57,180,192,65,127,106,118,66,104,145,191,65,16,216,56,66,82,184,192,65,98,205,
204,34,66,139,108,193,65,231,251,12,66,37,6,211,65,190,159,249,65,223,79,241,65,108,158,239,247,65,133,235,242,65,108,160,26,101,65,168,198,79,65,98,94,186,182,65,133,235,153,64,90,228,9,66,88,57,52,61,90,228,57,66,111,18,131,59,98,90,228,57,66,111,18,
131,59,174,199,184,66,111,18,131,59,174,199,184,66,111,18,131,59,98,174,199,184,66,18,131,0,65,174,199,184,66,225,122,128,65,174,199,184,66,57,180,192,65,99,109,174,135,142,67,57,180,192,65,108,27,207,84,67,57,180,192,65,108,27,207,84,67,111,18,131,59,
108,174,135,142,67,111,18,131,59,108,174,135,142,67,57,180,192,65,99,109,154,185,60,67,57,180,192,65,108,176,242,232,66,57,180,192,65,108,176,242,232,66,111,18,131,59,108,154,185,60,67,111,18,131,59,108,154,185,60,67,57,180,192,65,99,101,0,0 };

	static const unsigned char probeIcon[] = { 110,109,176,114,160,64,164,112,173,63,108,180,200,54,64,164,112,173,63,108,180,200,54,64,0,0,0,0,108,115,104,205,64,0,0,0,0,98,109,231,215,64,0,0,0,0,215,163,224,64,143,194,117,62,113,61,226,64,123,20,14,63,108,211,77,226,64,123,20,14,63,108,211,77,226,
64,59,223,15,63,98,152,110,226,64,98,16,24,63,43,135,226,64,18,131,32,63,43,135,226,64,195,245,40,63,108,43,135,226,64,164,112,173,63,108,211,77,226,64,164,112,173,63,108,211,77,226,64,219,249,202,64,98,205,204,172,64,18,131,22,65,141,151,110,64,31,133,
71,65,227,165,3,64,68,139,120,65,98,246,40,252,63,51,51,123,65,66,96,5,64,225,122,126,65,156,196,16,64,82,184,126,65,98,41,92,247,64,18,131,129,65,238,124,83,65,129,149,129,65,225,122,149,65,33,176,126,65,98,250,126,154,65,59,223,125,65,84,227,157,65,
168,198,113,65,53,94,155,65,117,147,104,65,108,145,237,108,65,143,194,205,64,108,195,245,108,65,164,112,173,63,108,72,225,108,65,164,112,173,63,98,72,225,108,65,164,112,173,63,72,225,108,65,215,163,128,63,72,225,108,65,195,245,40,63,98,72,225,108,65,
193,202,33,63,121,233,108,65,190,159,26,63,195,245,108,65,70,182,19,63,108,195,245,108,65,72,225,250,62,108,100,59,109,65,72,225,250,62,98,152,110,110,65,244,253,84,62,68,139,114,65,0,0,0,0,164,112,119,65,0,0,0,0,108,88,57,152,65,0,0,0,0,108,88,57,152,
65,164,112,173,63,108,170,241,134,65,164,112,173,63,108,145,237,134,65,29,90,188,64,108,119,190,169,65,43,135,88,65,98,190,159,177,65,248,83,117,65,199,75,167,65,133,235,142,65,180,200,149,65,229,208,143,65,98,213,120,83,65,225,122,144,65,33,176,246,
64,188,116,144,65,244,253,12,64,229,208,143,65,98,174,71,33,63,51,51,143,65,203,161,5,191,14,45,128,65,217,206,119,62,12,2,105,65,108,176,114,160,64,14,45,186,64,108,176,114,160,64,164,112,173,63,99,109,78,98,240,64,143,194,3,65,108,254,212,128,64,145,
237,108,65,108,0,0,145,65,111,18,107,65,108,59,223,103,65,92,143,6,65,98,59,223,103,65,92,143,6,65,12,2,95,65,129,149,243,64,63,53,58,65,102,102,10,65,98,139,108,21,65,244,253,26,65,78,98,240,64,143,194,3,65,78,98,240,64,143,194,3,65,99,101,0,0 };


	static const unsigned char colourIcon[] = { 110,109,115,104,89,64,143,194,9,65,98,248,83,35,63,63,53,34,65,219,249,126,191,203,161,93,65,186,73,44,63,90,100,135,65,98,66,96,21,64,254,212,159,65,180,200,218,64,106,188,167,65,37,6,27,65,211,77,151,65,98,27,47,7,65,231,251,138,65,186,73,248,64,84,
	227,117,65,209,34,251,64,14,45,86,65,98,203,161,249,64,84,227,85,65,197,32,248,64,129,149,85,65,190,159,246,64,174,71,85,65,98,125,63,181,64,133,235,71,65,49,8,132,64,209,34,43,65,115,104,89,64,143,194,9,65,99,109,229,208,144,65,63,53,6,65,98,182,243,
	143,65,221,36,12,65,254,212,142,65,74,12,18,65,152,110,141,65,35,219,23,65,98,133,235,134,65,47,221,50,65,197,32,118,65,55,137,71,65,117,147,90,65,233,38,83,65,98,201,118,94,65,98,16,108,65,180,200,90,65,172,28,131,65,170,241,76,65,209,34,143,65,98,217,
	206,73,65,59,223,145,65,63,53,70,65,139,108,148,65,113,61,66,65,217,206,150,65,98,166,155,102,65,102,102,162,65,115,104,141,65,106,188,162,65,244,253,157,65,174,71,147,65,98,231,251,173,65,78,98,132,65,123,20,178,65,152,110,84,65,184,30,167,65,4,86,46,
	65,98,37,6,162,65,215,163,28,65,123,20,154,65,240,167,14,65,229,208,144,65,63,53,6,65,99,109,49,8,66,65,23,217,90,65,98,102,102,52,65,119,190,93,65,29,90,38,65,250,126,94,65,117,147,24,65,229,208,92,65,98,252,169,23,65,150,67,107,65,172,28,26,65,123,
	20,122,65,106,188,32,65,209,34,132,65,98,246,40,36,65,193,202,135,65,141,151,40,65,184,30,139,65,217,206,45,65,160,26,142,65,98,35,219,59,65,35,219,132,65,12,2,67,65,147,24,114,65,49,8,66,65,23,217,90,65,99,109,137,65,46,65,131,192,36,65,98,193,202,39,
	65,233,38,45,65,43,135,34,65,18,131,54,65,180,200,30,65,127,106,64,65,98,47,221,40,65,143,194,65,65,184,30,51,65,45,178,65,65,184,30,61,65,197,32,64,65,98,98,16,60,65,12,2,61,65,254,212,58,65,133,235,57,65,115,104,57,65,96,229,54,65,98,78,98,54,65,127,
	106,48,65,190,159,50,65,4,86,42,65,137,65,46,65,131,192,36,65,99,109,8,172,131,65,215,163,252,64,98,2,43,129,65,160,26,251,64,125,63,125,65,4,86,250,64,197,32,120,65,102,102,250,64,98,82,184,98,65,100,59,251,64,141,151,78,65,113,61,6,65,78,98,62,65,84,
	227,19,65,98,139,108,71,65,150,67,31,65,106,188,78,65,98,16,44,65,10,215,83,65,20,174,57,65,98,219,249,92,65,193,202,53,65,6,129,101,65,78,98,48,65,61,10,109,65,41,92,41,65,98,55,137,121,65,70,182,29,65,100,59,129,65,215,163,14,65,8,172,131,65,215,163,
	252,64,99,109,229,208,24,65,201,118,16,65,98,211,77,8,65,170,241,4,65,68,139,232,64,68,139,252,64,219,249,190,64,254,212,252,64,98,72,225,178,64,86,14,253,64,219,249,166,64,141,151,254,64,188,116,155,64,240,167,0,65,98,102,102,158,64,125,63,5,65,221,
	36,162,64,193,202,9,65,82,184,166,64,162,69,14,65,98,180,200,186,64,10,215,33,65,174,71,221,64,4,86,48,65,33,176,2,65,205,204,56,65,98,178,157,3,65,168,198,53,65,33,176,4,65,205,204,50,65,109,231,5,65,10,215,47,65,98,117,147,10,65,152,110,36,65,12,2,
	17,65,59,223,25,65,229,208,24,65,201,118,16,65,99,109,254,212,133,65,217,206,199,64,98,147,24,134,65,70,182,167,64,201,118,132,65,139,108,135,64,156,196,128,65,27,47,85,64,98,12,2,113,65,39,49,168,63,10,215,77,65,244,253,84,188,27,47,41,65,0,0,0,0,98,
	82,184,234,64,37,6,129,61,4,86,146,64,80,141,71,64,121,233,146,64,119,190,203,64,98,51,51,163,64,18,131,200,64,59,223,179,64,23,217,198,64,106,188,196,64,219,249,198,64,98,133,235,249,64,158,239,199,64,84,227,21,65,86,14,221,64,14,45,42,65,43,135,254,
	64,98,43,135,64,65,182,243,217,64,209,34,93,65,246,40,196,64,12,2,123,65,18,131,196,64,98,236,81,128,65,106,188,196,64,160,26,131,65,35,219,197,64,254,212,133,65,217,206,199,64,99,101,0,0 };

	static const unsigned char swapOrientationIcon[] = { 110,109,176,186,20,68,113,237,218,67,98,127,106,24,68,113,237,218,67,197,104,27,68,252,233,224,67,197,104,27,68,154,73,232,67,108,197,104,27,68,27,47,8,68,98,197,104,27,68,233,222,11,68,127,106,24,68,31,221,14,68,176,186,20,68,47,221,14,68,108,248,51,
18,67,47,221,14,68,98,188,116,3,67,47,221,14,68,76,247,238,66,233,222,11,68,76,247,238,66,27,47,8,68,108,76,247,238,66,154,73,232,67,98,76,247,238,66,252,233,224,67,188,116,3,67,113,237,218,67,248,51,18,67,113,237,218,67,108,176,186,20,68,113,237,218,
67,99,109,92,207,237,66,0,0,0,0,98,180,8,254,66,0,0,0,0,219,153,5,67,82,184,210,64,219,153,5,67,209,34,107,65,108,219,153,5,67,248,243,195,67,108,236,145,223,66,248,243,195,67,98,227,165,184,66,25,244,195,67,205,12,153,66,94,218,203,67,205,12,153,66,
96,149,213,67,98,205,12,153,66,96,149,213,67,184,94,153,66,254,68,255,67,55,137,153,66,141,167,6,68,98,223,143,153,66,203,193,7,68,129,149,153,66,205,132,8,68,154,153,153,66,4,206,8,68,108,209,34,107,65,45,202,8,68,98,82,184,210,64,45,202,8,68,0,0,0,
0,188,36,7,68,0,0,0,0,162,29,5,68,108,0,0,0,0,209,34,107,65,98,0,0,0,0,82,184,210,64,82,184,210,64,0,0,0,0,209,34,107,65,0,0,0,0,108,92,207,237,66,0,0,0,0,99,109,96,133,221,67,92,111,91,67,108,170,201,6,68,233,166,246,66,108,170,201,6,68,111,18,192,67,
108,0,16,139,67,14,45,192,67,108,18,163,177,67,252,153,153,67,108,109,135,66,67,63,117,18,67,108,4,38,141,67,143,194,106,66,108,96,133,221,67,92,111,91,67,99,101,0,0 };

	static const unsigned char cableIcon[] = { 110,109,174,71,121,65,139,108,156,65,98,76,55,113,65,252,169,157,65,240,167,104,65,236,81,158,65,168,198,95,65,186,73,158,65,98,131,192,48,65,221,36,158,65,229,208,10,65,158,239,138,65,160,26,11,65,23,217,102,65,98,90,100,11,65,242,210,55,65,242,210,
	49,65,84,227,17,65,23,217,96,65,14,45,18,65,98,158,239,135,65,201,118,18,65,109,231,154,65,72,225,56,65,131,192,154,65,109,231,103,65,98,57,180,154,65,98,16,120,65,115,104,152,65,104,145,131,65,188,116,148,65,231,251,137,65,108,244,253,203,65,233,38,
	217,65,108,41,92,179,65,152,110,234,65,108,174,71,121,65,139,108,156,65,99,109,248,83,147,65,195,245,221,65,98,217,206,87,65,141,151,234,65,227,165,247,64,201,118,228,65,100,59,119,64,55,137,198,65,98,215,163,128,192,252,169,137,65,199,75,23,63,12,2,
	43,62,190,159,92,65,0,0,0,0,98,178,157,95,65,0,0,0,0,154,153,95,65,0,0,0,0,117,147,98,65,111,18,3,59,98,250,126,189,65,217,206,119,62,147,24,251,65,211,77,56,65,254,212,214,65,14,45,166,65,98,164,112,211,65,147,24,173,65,174,71,207,65,6,129,179,65,238,
	124,202,65,41,92,185,65,108,76,55,184,65,223,79,159,65,98,240,167,198,65,53,94,134,65,238,124,200,65,207,247,75,65,49,8,187,65,88,57,24,65,98,152,110,172,65,246,40,192,64,137,65,144,65,139,108,111,64,12,2,93,65,139,108,111,64,98,178,157,215,64,27,47,
	117,64,207,247,115,63,182,243,65,65,219,249,134,64,61,10,152,65,98,145,237,200,64,205,204,186,65,248,83,57,65,250,126,204,65,221,36,130,65,213,120,197,65,108,248,83,147,65,195,245,221,65,99,101,0,0 };

	static const unsigned char foldIcon[] = { 110,109,123,20,116,65,141,151,178,65,108,109,231,139,65,106,188,160,65,108,211,77,204,65,209,34,225,65,108,176,114,186,65,0,0,243,65,108,109,231,139,65,188,116,196,65,108,135,22,57,65,217,206,243,65,108,41,92,21,65,182,243,225,65,108,123,20,116,65,141,
	151,178,65,99,109,250,126,11,66,233,38,77,65,108,250,126,11,66,100,59,141,65,108,0,0,0,0,100,59,141,65,108,0,0,0,0,233,38,77,65,108,250,126,11,66,233,38,77,65,99,109,135,22,139,65,164,112,189,64,108,176,114,186,65,0,0,0,0,108,211,77,204,65,121,233,14,
	64,108,182,243,156,65,152,110,2,65,108,135,22,139,65,246,40,38,65,108,41,92,21,65,66,96,21,64,108,135,22,57,65,23,217,206,61,108,135,22,139,65,164,112,189,64,99,101,0,0 };

	static const unsigned char foldUnselected[] = { 110,109,86,206,13,67,90,228,219,66,108,33,48,29,67,197,32,189,66,108,35,27,29,67,45,146,16,67,108,51,51,214,66,233,166,16,67,108,221,36,243,66,20,46,2,67,108,86,206,13,67,20,46,2,67,108,86,206,13,67,90,228,219,66,99,109,172,28,118,65,90,228,219,66,108,
0,0,0,0,197,32,189,66,108,158,239,167,61,45,146,16,67,108,29,90,72,66,233,166,16,67,108,201,118,14,66,20,46,2,67,108,172,28,118,65,20,46,2,67,108,172,28,118,65,90,228,219,66,99,109,254,84,250,66,4,22,142,66,108,240,39,227,66,4,22,142,66,108,240,39,227,
66,35,27,204,66,108,172,156,53,66,35,27,204,66,108,172,156,53,66,4,22,142,66,108,113,189,4,66,4,22,142,66,108,113,189,4,66,162,5,228,66,108,254,84,250,66,162,5,228,66,108,254,84,250,66,4,22,142,66,99,109,74,204,254,66,80,13,133,66,108,74,204,254,66,133,
235,252,65,108,178,157,247,65,133,235,252,65,108,178,157,247,65,80,13,133,66,108,74,204,254,66,80,13,133,66,99,109,86,206,13,67,242,210,10,66,108,33,48,29,67,29,90,72,66,108,35,27,29,67,158,239,167,61,108,51,51,214,66,0,0,0,0,108,221,36,243,66,80,141,
103,65,108,86,206,13,67,80,141,103,65,108,86,206,13,67,242,210,10,66,99,109,172,28,118,65,242,210,10,66,108,0,0,0,0,29,90,72,66,108,158,239,167,61,158,239,167,61,108,29,90,72,66,0,0,0,0,108,201,118,14,66,80,141,103,65,108,172,28,118,65,80,141,103,65,
108,172,28,118,65,242,210,10,66,99,101,0,0 };

	static const unsigned char gotoIcon[] = { 110,109,111,146,38,66,106,188,168,64,108,35,91,38,66,106,188,168,64,108,35,91,38,66,41,92,217,65,108,215,35,38,66,41,92,217,65,108,215,35,38,66,227,165,218,65,108,57,180,102,65,227,165,218,65,108,57,180,102,65,213,120,176,65,108,150,67,17,66,213,120,
	176,65,108,150,67,17,66,106,188,168,64,108,152,110,104,65,106,188,168,64,108,152,110,104,65,0,0,0,0,108,111,146,38,66,0,0,0,0,108,111,146,38,66,106,188,168,64,99,109,0,0,0,0,219,249,132,65,108,0,0,0,0,199,75,31,65,108,236,81,12,65,199,75,31,65,108,236,
	81,12,65,37,6,113,64,108,16,88,146,65,190,159,84,65,108,236,81,12,65,250,126,182,65,108,236,81,12,65,219,249,132,65,108,0,0,0,0,219,249,132,65,99,101,0,0 };

    static const unsigned char ejectIcon[] = { 110,109,92,39,186,68,113,205,176,68,108,16,248,8,68,113,205,176,68,108,16,248,8,68,92,127,213,68,108,92,39,186,68,92,127,213,68,108,92,39,186,68,113,205,176,68,99,109,225,162,128,68,213,120,66,68,108,41,124,187,68,10,151,154,68,108,209,146,11,68,10,151,
154,68,108,225,162,128,68,213,120,66,68,99,101,0,0 };

	static const unsigned char propertyIcon[] = { 110,109,0,0,0,0,0,0,0,0,108,152,110,39,66,0,0,0,0,108,152,110,39,66,57,180,102,65,108,174,71,39,66,57,180,102,65,108,174,71,39,66,201,246,29,66,98,172,28,39,66,178,157,33,66,119,62,36,66,43,135,36,66,68,139,32,66,45,178,36,66,108,127,106,220,63,45,178,
	36,66,98,141,151,78,63,43,135,36,66,10,215,163,61,147,152,33,66,227,165,27,61,201,246,29,66,108,227,165,27,61,57,180,102,65,108,0,0,0,0,57,180,102,65,108,0,0,0,0,0,0,0,0,99,109,223,207,25,66,57,180,102,65,108,133,235,89,64,57,180,102,65,108,133,235,89,
	64,94,58,23,66,108,223,207,25,66,94,58,23,66,108,223,207,25,66,57,180,102,65,99,109,254,212,10,65,39,49,226,65,108,236,81,6,66,39,49,226,65,108,236,81,6,66,209,34,7,66,108,254,212,10,65,209,34,7,66,108,254,212,10,65,39,49,226,65,99,109,254,212,10,65,
	121,233,153,65,108,236,81,6,66,121,233,153,65,108,236,81,6,66,244,253,197,65,108,254,212,10,65,244,253,197,65,108,254,212,10,65,121,233,153,65,99,101,0,0 };

	static const unsigned char zoom[] = { 110,109,223,79,184,65,254,212,218,65,98,47,221,141,65,63,53,245,65,76,55,37,65,166,155,246,65,238,124,167,64,231,251,212,65,98,90,100,139,191,113,61,171,65,41,92,239,191,154,153,43,65,92,143,122,64,233,38,149,64,98,66,96,213,64,248,83,227,63,244,253,
	40,65,193,202,161,61,80,141,105,65,111,18,131,58,98,33,176,108,65,0,0,0,0,8,172,108,65,0,0,0,0,168,198,111,65,111,18,131,58,98,127,106,200,65,57,180,72,62,43,7,5,66,10,215,67,65,82,184,224,65,125,63,176,65,98,178,157,222,65,125,63,180,65,137,65,220,65,
	111,18,184,65,8,172,217,65,94,186,187,65,108,137,193,26,66,180,200,11,66,108,215,163,10,66,102,230,27,66,108,223,79,184,65,254,212,218,65,99,109,137,65,106,65,104,145,85,64,98,121,233,214,64,41,92,95,64,96,229,208,62,254,212,80,65,236,81,144,64,180,200,
	164,65,98,176,114,252,64,18,131,214,65,211,77,139,65,213,120,228,65,61,10,182,65,45,178,188,65,98,215,163,210,65,111,18,162,65,109,231,219,65,76,55,105,65,221,36,203,65,188,116,33,65,98,244,253,187,65,76,55,193,64,106,188,153,65,129,149,83,64,137,65,
	106,65,104,145,85,64,99,101,0,0 };

	

	static const unsigned char profileIcon[] = { 110,109,72,225,30,66,0,0,0,0,98,248,211,103,66,197,32,48,62,39,177,149,66,201,118,98,65,217,142,156,66,33,48,0,66,98,195,117,161,66,174,71,51,66,193,202,152,66,131,192,106,66,84,35,134,66,10,151,135,66,98,70,182,96,66,166,219,156,66,109,103,27,66,170,
	241,163,66,113,61,196,65,231,59,152,66,98,201,118,254,64,20,174,138,66,61,10,39,192,98,16,73,66,59,223,15,63,197,32,2,66,98,158,239,111,64,238,124,107,65,47,221,163,65,115,104,209,62,217,206,26,66,66,96,229,59,98,252,41,28,66,111,18,131,58,37,134,29,
	66,111,18,131,186,72,225,30,66,0,0,0,0,99,109,111,18,29,66,100,59,17,65,98,33,176,203,65,223,79,19,65,12,2,71,65,254,212,157,65,113,61,26,65,61,138,5,66,98,100,59,183,64,158,239,81,66,162,69,189,65,96,101,147,66,252,169,53,66,156,196,138,66,98,246,168,
	102,66,246,232,133,66,250,190,135,66,4,214,96,66,94,58,139,66,190,31,47,66,98,57,244,143,66,4,86,215,65,250,126,104,66,25,4,20,65,233,166,30,66,100,59,17,65,98,190,31,30,66,76,55,17,65,154,153,29,66,76,55,17,65,111,18,29,66,100,59,17,65,99,109,244,253,
	241,65,231,251,102,66,108,90,100,200,65,231,251,102,66,108,27,47,60,66,18,131,172,65,108,2,171,81,66,70,182,172,65,108,244,253,241,65,231,251,102,66,99,109,78,226,76,66,31,133,101,66,98,27,175,65,66,31,133,101,66,23,217,56,66,133,235,97,66,59,95,50,66,
	94,186,90,66,98,90,228,43,66,49,136,83,66,233,166,40,66,207,119,74,66,233,166,40,66,43,135,63,66,98,233,166,40,66,72,225,37,66,207,119,52,66,80,13,25,66,160,26,76,66,80,13,25,66,98,137,193,87,66,80,13,25,66,39,177,96,66,129,149,28,66,115,232,102,66,227,
	165,35,66,98,197,32,109,66,70,182,42,66,106,60,112,66,66,224,51,66,106,60,112,66,215,35,63,66,98,106,60,112,66,215,35,74,66,92,15,109,66,186,73,83,66,70,182,102,66,123,148,90,66,98,53,94,96,66,59,223,97,66,137,193,87,66,31,133,101,66,78,226,76,66,31,
	133,101,66,99,109,14,45,77,66,244,253,85,66,98,55,9,83,66,244,253,85,66,176,114,87,66,41,220,83,66,115,104,90,66,147,152,79,66,98,59,95,93,66,254,84,75,66,29,218,94,66,223,207,69,66,29,218,94,66,61,10,63,66,98,29,218,94,66,162,69,56,66,162,69,93,66,236,
	209,50,66,178,29,90,66,27,175,46,66,98,195,245,86,66,80,141,42,66,137,65,82,66,231,123,40,66,6,1,76,66,231,123,40,66,98,137,193,69,66,231,123,40,66,90,100,65,66,49,136,42,66,133,235,62,66,209,162,46,66,98,170,113,60,66,106,188,50,66,63,53,59,66,53,94,
	56,66,63,53,59,66,43,135,63,66,98,63,53,59,66,205,76,70,66,82,184,60,66,106,188,75,66,125,191,63,66,10,215,79,66,98,168,198,66,66,164,240,83,66,131,64,71,66,244,253,85,66,14,45,77,66,244,253,85,66,99,109,4,86,219,65,119,190,33,66,98,172,28,198,65,119,
	190,33,66,127,106,181,65,252,41,30,66,113,61,169,65,6,1,23,66,98,98,16,157,65,10,215,15,66,219,249,150,65,94,186,6,66,219,249,150,65,236,81,247,65,98,219,249,150,65,27,47,225,65,150,67,157,65,242,210,206,65,242,210,169,65,113,61,192,65,98,90,100,182,
	65,240,167,177,65,88,57,199,65,53,94,170,65,223,79,220,65,53,94,170,65,98,236,81,242,65,53,94,170,65,236,209,1,66,43,135,177,65,203,33,8,66,23,217,191,65,98,176,114,14,66,2,43,206,65,166,155,17,66,201,118,224,65,166,155,17,66,94,186,246,65,98,166,155,
	17,66,53,94,6,66,236,81,14,66,25,132,15,66,119,190,7,66,217,206,22,66,98,2,43,1,66,154,25,30,66,182,243,240,65,119,190,33,66,4,86,219,65,119,190,33,66,99,109,145,237,219,65,76,55,18,66,98,137,65,231,65,76,55,18,66,229,208,239,65,154,25,16,66,166,155,
	245,65,53,222,11,66,98,102,102,251,65,215,163,7,66,199,75,254,65,2,43,2,66,199,75,254,65,145,237,246,65,98,199,75,254,65,137,65,233,65,102,102,251,65,27,47,222,65,166,155,245,65,82,184,213,65,98,229,208,239,65,150,67,205,65,236,81,231,65,49,8,201,65,
	184,30,220,65,49,8,201,65,98,133,235,208,65,49,8,201,65,188,116,200,65,248,83,205,65,94,186,194,65,133,235,213,65,98,0,0,189,65,18,131,222,65,209,34,186,65,227,165,233,65,209,34,186,65,236,81,247,65,98,209,34,186,65,250,126,2,66,207,247,188,65,201,246,
	7,66,203,161,194,65,98,16,12,66,98,199,75,200,65,2,43,16,66,94,186,208,65,76,55,18,66,145,237,219,65,76,55,18,66,99,101,0,0 };
}

Array<PathFactory::Description> DspNetworkPathFactory::getDescription() const
{
	Array<Description> d;

#define ADD_DESC(x) d.add({x, x});

	ADD_DESC("probe");
	ADD_DESC("colour");
	ADD_DESC("cable");
	ADD_DESC("fold");
	ADD_DESC("foldunselected");
	ADD_DESC("deselect");
	ADD_DESC("undo");
    ADD_DESC("eject");
	ADD_DESC("redo");
	ADD_DESC("rebuild");
	ADD_DESC("goto");
	ADD_DESC("properties");
	ADD_DESC("bypass");
	ADD_DESC("profile");
	ADD_DESC("swap-orientation");
	ADD_DESC("copy");
	ADD_DESC("delete");
	ADD_DESC("duplicate");
	ADD_DESC("add");
	ADD_DESC("zoom");
	ADD_DESC("zoom-out");
	ADD_DESC("zoom-fit");
	ADD_DESC("zoom-sel");
    ADD_DESC("signal");
	ADD_DESC("error");
	ADD_DESC("export");
	ADD_DESC("wrap");
	ADD_DESC("parameters");
	ADD_DESC("surround");
    ADD_DESC("save");
    ADD_DESC("export");
	ADD_DESC("debug");

#undef ADD_DESC

	return d;
}


juce::Path DspNetworkPathFactory::createPath(const String& url) const
{
	Path p;

#if USE_BACKEND
	LOAD_PATH_IF_URL("probe", ScriptnodeIcons::probeIcon);
	LOAD_PATH_IF_URL("colour", ScriptnodeIcons::colourIcon);
	LOAD_PATH_IF_URL("cable", ScriptnodeIcons::cableIcon);
	LOAD_PATH_IF_URL("fold", ScriptnodeIcons::foldIcon);
	LOAD_PATH_IF_URL("foldunselected", ScriptnodeIcons::foldUnselected);
	LOAD_EPATH_IF_URL("deselect", EditorIcons::cancelIcon);
	LOAD_EPATH_IF_URL("undo", EditorIcons::undoIcon);
    LOAD_PATH_IF_URL("eject", ScriptnodeIcons::ejectIcon);
	LOAD_EPATH_IF_URL("redo", EditorIcons::redoIcon);
	LOAD_PATH_IF_URL("rebuild", ColumnIcons::moveIcon);
	LOAD_PATH_IF_URL("comment", ColumnIcons::commentIcon);
	LOAD_PATH_IF_URL("goto", ScriptnodeIcons::gotoIcon);
	LOAD_PATH_IF_URL("properties", ScriptnodeIcons::propertyIcon);
	LOAD_EPATH_IF_URL("bypass", HiBinaryData::ProcessorEditorHeaderIcons::bypassShape);
	LOAD_PATH_IF_URL("profile", ScriptnodeIcons::profileIcon);
	LOAD_PATH_IF_URL("swap-orientation", ScriptnodeIcons::swapOrientationIcon);
	LOAD_EPATH_IF_URL("copy", SampleMapIcons::copySamples);
	LOAD_EPATH_IF_URL("delete", SampleMapIcons::deleteSamples);
	LOAD_EPATH_IF_URL("duplicate", SampleMapIcons::duplicateSamples);
	LOAD_EPATH_IF_URL("add", HiBinaryData::ProcessorEditorHeaderIcons::addIcon);
	LOAD_PATH_IF_URL("zoom", ScriptnodeIcons::zoomOriginal);
	LOAD_PATH_IF_URL("zoom-in", ScriptnodeIcons::zoomIn);
	LOAD_PATH_IF_URL("zoom-out", ScriptnodeIcons::zoomOut);
	LOAD_EPATH_IF_URL("zoom-fit", ::ScriptnodeIcons::zoomFit);
	LOAD_PATH_IF_URL("zoom-sel", ScriptnodeIcons::zoomSelection);
    LOAD_PATH_IF_URL("signal", ScriptnodeIcons::signalIcon);
	LOAD_EPATH_IF_URL("error", ::ScriptnodeIcons::errorIcon);
	LOAD_EPATH_IF_URL("export", HnodeIcons::freezeIcon);
	LOAD_EPATH_IF_URL("wrap", HnodeIcons::mapIcon);
	LOAD_EPATH_IF_URL("parameters", HiBinaryData::SpecialSymbols::macros);
	LOAD_EPATH_IF_URL("surround", HnodeIcons::injectNodeIcon);
    LOAD_EPATH_IF_URL("save", SampleMapIcons::saveSampleMap);
    LOAD_EPATH_IF_URL("export", SampleMapIcons::monolith);
	LOAD_PATH_IF_URL("lock", ColumnIcons::lockIcon);
	LOAD_PATH_IF_URL("debug", SnexIcons::bugIcon);
#endif

	return p;
}

DspNetworkGraph::DspNetworkGraph(DspNetwork* n) :
	network(n),
	dataReference(n->getValueTree()),
	dragOverlay(*this),
	rootUndoButtons(*this)
{
	addChildComponent(rootUndoButtons);
	network->addSelectionListener(this);
	rebuildNodes();
	setWantsKeyboardFocus(true);

	lockListener.setCallback(dataReference, { PropertyIds::Locked},
		valuetree::AsyncMode::Asynchronously,
	[this](ValueTree v, Identifier id)
	{
		rebuildNodes();
	});

	cableRepainter.setCallback(dataReference, { PropertyIds::Bypassed },
		valuetree::AsyncMode::Asynchronously,
		[this](ValueTree v, Identifier id)
	{
		repaint();
	});

	rebuildListener.setCallback(dataReference, valuetree::AsyncMode::Synchronously,
		[this](ValueTree c, bool)
	{
			if (c.getType() == PropertyIds::Node)
			    triggerAsyncUpdate();
	});

	macroListener.setTypeToWatch(PropertyIds::Parameters);
	macroListener.setCallback(dataReference, valuetree::AsyncMode::Asynchronously,
		[this](ValueTree, bool)
	{
		this->rebuildNodes();
	});

	rebuildListener.forwardCallbacksForChildEvents(true);

	resizeListener.setCallback(dataReference, { PropertyIds::Folded, PropertyIds::ShowParameters, PropertyIds::ShowClones, PropertyIds::DisplayedClones },
		valuetree::AsyncMode::Asynchronously,
		[this](ValueTree, Identifier id)
	{
		if (id == PropertyIds::ShowClones || id == PropertyIds::DisplayedClones)
			this->rebuildNodes();
		else
			this->resizeNodes();
	});

	n->getExceptionHandler().errorBroadcaster.addListener(*this, [](DspNetworkGraph& g, NodeBase* , Error )
	{
		g.resizeNodes();
	});

	setOpaque(true);
}

DspNetworkGraph::~DspNetworkGraph()
{
	if (network != nullptr)
		network->removeSelectionListener(this);

	periodicRepainter = nullptr;
	root = nullptr;


	network = nullptr;
}

bool DspNetworkGraph::keyPressed(const KeyPress& key)
{
	if (TopLevelWindowWithKeyMappings::matches(this, key, ScriptnodeShortcuts::sn_deselect_all))
		return Actions::deselectAll(*this);
	if (key == KeyPress::deleteKey || key == KeyPress::backspaceKey)
		return Actions::deleteSelection(*this);
	if ((key.isKeyCode('z') || key.isKeyCode('Z')) && key.getModifiers().isCommandDown())
		return Actions::undo(*this);
	if ((key.isKeyCode('Y') || key.isKeyCode('Y')) && key.getModifiers().isCommandDown())
		return Actions::redo(*this);
	if (TopLevelWindowWithKeyMappings::matches(this, key, ScriptnodeShortcuts::sn_duplicate))
		return Actions::duplicateSelection(*this);
	if (TopLevelWindowWithKeyMappings::matches(this, key, ScriptnodeShortcuts::sn_new_node))
		return Actions::showKeyboardPopup(*this, KeyboardPopup::Mode::New);
	if (TopLevelWindowWithKeyMappings::matches(this, key, ScriptnodeShortcuts::sn_fold))
		return Actions::foldSelection(*this);
	if (TopLevelWindowWithKeyMappings::matches(this, key, ScriptnodeShortcuts::sn_add_bookmark))
	{
		Actions::addBookMark(network.get());
		return true;
	}
	if(TopLevelWindowWithKeyMappings::matches(this, key, ScriptnodeShortcuts::sn_zoom_fit))
		return Actions::zoomFit(*this);
	if(TopLevelWindowWithKeyMappings::matches(this, key, ScriptnodeShortcuts::sn_zoom_reset))
		return Actions::foldUnselectedNodes(*this);
	if (TopLevelWindowWithKeyMappings::matches(this, key, ScriptnodeShortcuts::sn_edit_property))
		return Actions::editNodeProperty(*this);
	if ((key).isKeyCode('+') && key.getModifiers().isCommandDown())
		return Actions::zoomIn(*this);
	if ((key).isKeyCode('-') && key.getModifiers().isCommandDown())
		return Actions::zoomOut(*this);
	if (TopLevelWindowWithKeyMappings::matches(this, key, ScriptnodeShortcuts::sn_toggle_bypass))
		return Actions::toggleBypass(*this);
	if (TopLevelWindowWithKeyMappings::matches(this, key, ScriptnodeShortcuts::sn_toggle_cables))
		return Actions::toggleCableDisplay(*this);
	if (((key).isKeyCode('c') || key.isKeyCode('C')) && key.getModifiers().isCommandDown())
		return Actions::copyToClipboard(*this);
	if (key == KeyPress::upKey || key == KeyPress::downKey)
		return Actions::arrowKeyAction(*this, key);

	return false;
}

void DspNetworkGraph::handleAsyncUpdate()
{
	rebuildNodes();
}

void DspNetworkGraph::rebuildNodes()
{
	ScopedValueSetter<bool> svs(dynamic_cast<NodeContainer*>(getCurrentRootNode())->forceNoLock, true);
	addAndMakeVisible(root = dynamic_cast<NodeComponent*>(getCurrentRootNode()->createComponent()));

	if(currentRootNode != nullptr)
		currentRootNode->getHelpManager().setShowComments(true);

	rebuildBreadCrumbs();
	resizeNodes();
}

void DspNetworkGraph::resizeNodes()
{
	ScopedValueSetter<bool> svs(dynamic_cast<NodeContainer*>(getCurrentRootNode())->forceNoLock, true);

    Component::callRecursive<NodeComponent>(this, [](NodeComponent* nc)
    {
        if(auto mc = dynamic_cast<WrapperNode*>(nc->node.get()))
        {
            mc->setCachedSize(-1, -1);
        }
        
        return false;
    });
    
	auto b = getCurrentRootNode()->getPositionInCanvas({ UIValues::NodeMargin, UIValues::NodeMargin });

	if(isShowingRootNode())
	{
		auto& hm = getCurrentRootNode()->getHelpManager();

		auto helpBounds = hm.getHelpSize();

		if(!helpBounds.isEmpty())
		{
			if(hm.isHelpBelow())
				b.removeFromTop(-helpBounds.getHeight());
			else
				b.removeFromRight(-helpBounds.getWidth());
		}
	}

	auto breadCrumbWidth = UIValues::ZoomOffset;

	for(auto bc: breadcrumbs)
	{
		breadCrumbWidth += bc->getWidth();
	}

	auto wToUse = jmax(breadCrumbWidth, b.getWidth() + 2 * UIValues::NodeMargin);
	setSize(wToUse, b.getHeight() + 2 * UIValues::NodeMargin + (!isShowingRootNode() ? UIValues::ZoomOffset : 0));
	resized();
}

void DspNetworkGraph::updateDragging(Point<int> position, bool copyNode)
{
	copyDraggedNode = copyNode;

	if (auto c = dynamic_cast<NodeDropTarget*>(root.get()))
	{
		c->setDropTarget({});
	}

	if (auto hoveredComponent = root->getComponentAt(position))
	{
		auto container = dynamic_cast<NodeDropTarget*>(hoveredComponent);

		if (container == nullptr)
			container = hoveredComponent->findParentComponentOfClass<NodeDropTarget>();

		if (container != nullptr)
		{
			if (currentDropTarget != nullptr && currentDropTarget != container)
				currentDropTarget->setDropTarget({ -1, -1 });

			currentDropTarget = container;
			auto pointInContainer = container->asComponent()->getLocalPoint(this, position);
			container->setDropTarget(pointInContainer);
		}
	}
}

void DspNetworkGraph::finishDrag()
{
	if (currentDropTarget != nullptr)
	{
		currentDropTarget->insertDraggedNode(currentlyDraggedComponent, copyDraggedNode);
	}
	
	rebuildNodes();
	currentlyDraggedComponent = nullptr;
}

void DspNetworkGraph::paint(Graphics& g)
{
	g.fillAll(JUCE_LIVE_CONSTANT_OFF(Colour(0xff1d1d1d)));
}

void DspNetworkGraph::resized()
{
	if (root != nullptr)
	{
		ScopedValueSetter<bool> svs(dynamic_cast<NodeContainer*>(getCurrentRootNode())->forceNoLock, true);

		auto b = getLocalBounds();

		rootUndoButtons.setVisible(!isShowingRootNode());

		if(!isShowingRootNode())
		{
			auto bcArea = b.removeFromTop(UIValues::ZoomOffset);

			bcArea.removeFromLeft(UIValues::NodeMargin);

			rootUndoButtons.setBounds(bcArea.removeFromLeft(UIValues::ZoomOffset));
			rootUndoButtons.resized();

			for(int i = breadcrumbs.size() - 1; i >= 0; i--)
			{
				auto bc = breadcrumbs[i];
				auto w = bc->getWidth();
				bc->setBounds(bcArea.removeFromLeft(w).withSizeKeepingCentre(w, 32));
			}
		}

		b = b.reduced(UIValues::NodeMargin);

		auto nb = getCurrentRootNode()->getPositionInCanvas({ UIValues::NodeMargin, UIValues::NodeMargin });

		if(!isShowingRootNode())
			nb = getCurrentRootNode()->getBoundsWithoutHelp(nb);

		nb = b.withSizeKeepingCentre(nb.getWidth(), nb.getHeight());

		if(!isShowingRootNode())
		{
			auto& hm = getCurrentRootNode()->getHelpManager();
			auto hb = hm.getHelpSize();

			if(!hm.isHelpBelow())
			{
				nb = nb.withX(UIValues::NodeMargin);
			}
			else
			{
				nb = nb.withY(b.getY());
			}
		}

		root->setBounds(nb);
		root->resized();
	}
}

struct RootUndoAction: public UndoableAction
{
	RootUndoAction(DspNetworkGraph& p_, NodeBase* prev_, NodeBase* current_):
	  UndoableAction(),
	  p(p_),
	  prev(prev_),
	  current(current_)
	{}

	bool perform() override
	{
		p.setCurrentRootNode(current, false);
		return true;
	}

	bool undo() override
	{
		p.setCurrentRootNode(prev, false);
		return true;
	}
	
	DspNetworkGraph& p;
	WeakReference<NodeBase> prev, current;
};

void DspNetworkGraph::setCurrentRootNode(NodeBase* newRoot, bool useUndo, bool allowAnimation)
{
	if(newRoot == network->getRootNode())
		newRoot = nullptr;

	if(newRoot == currentRootNode)
		return;

	if(useUndo)
	{
		String name;

		if(newRoot == nullptr)
			name << "show " << network->getId() << " as root";
		else
			name << "show " << newRoot->getName() << " as root";

		rootUndoManager.beginNewTransaction(name);
		rootUndoManager.perform(new RootUndoAction(*this, currentRootNode.get(), newRoot));
	}
	else
	{
		auto prevNode = getCurrentRootNode();

		currentRootNode = newRoot;

		auto newRootNode = getCurrentRootNode();

		auto zoomIn = newRootNode->getValueTree().isAChildOf(prevNode->getValueTree());

		rootBroadcaster.sendMessage(sendNotificationAsync, getCurrentRootNode());

		if(currentRootNode != nullptr && !network->isSignalDisplayEnabled())
		{
			network->setSignalDisplayEnabled(true);
		}

		if(currentRootNode == nullptr)
			network->setSignalDisplayEnabled(false);


		auto parent = findParentComponentOfClass<ZoomableViewport>();

		auto zoomFactor = zoomIn ? 1.008f : JUCE_LIVE_CONSTANT_OFF(0.993f);

		if(allowAnimation)
			parent->makeSwapSnapshot(zoomFactor);

		auto g = this;

		auto f = [parent, g]()
		{
			parent->clearSwapSnapshot();

			g->rebuildNodes();
			
			parent->zoomToRectangle(g->getLocalBounds().expanded(2* UIValues::NodeMargin));
			g->repaint();
			g->grabKeyboardFocus();
		};

		if(allowAnimation)
			Timer::callAfterDelay(JUCE_LIVE_CONSTANT_OFF(350), f);
		else
			f();
	}
}

Colour getSpecialColour(Component* c, Colour defaultColour)
{
	if (NodeComponent* nc = c->findParentComponentOfClass<NodeComponent>())
	{
		if(nc->header.colour.getSaturation() != 0.0)
			return nc->header.colour;
	}

	return defaultColour;
}



void drawBlockrateForCable(Graphics& g, Point<float> midPoint, Colour cableColour, float alpha, NodeBase* sourceNode, NodeBase* targetNode)
{
	NodeBase* commonParent;

	if (sourceNode == targetNode)
		commonParent = sourceNode;
	else
	{
		auto v1 = sourceNode->getValueTree();
		auto v2 = targetNode->getValueTree();

		auto p = ConnectionBase::Helpers::findCommonParent(v1, v2).getParent();

		commonParent = sourceNode->getRootNetwork()->getNodeForValueTree(p);
	}

	if (commonParent != nullptr)
	{
		String s;

		auto blockRate = commonParent->getCurrentBlockRate();

		if (blockRate == 1)
			s << "1 sample";
		else
			s << String(blockRate) << " samples";

		auto r = Rectangle<float>(midPoint, midPoint).withSizeKeepingCentre(GLOBAL_BOLD_FONT().getStringWidthFloat(s) + 15.0f, 24.0f);

		g.setFont(GLOBAL_BOLD_FONT());
		g.setColour(Colours::black.withAlpha(alpha));
		g.fillRoundedRectangle(r, r.getHeight() / 2.0f);
		g.setColour(cableColour.withAlpha(alpha));
		g.drawRoundedRectangle(r, r.getHeight() / 2.0f, 1.0f);
		g.drawText(s, r, Justification::centred);
	}
}



void DspNetworkGraph::paintOverChildren(Graphics& g)
{
	if(!isShowingRootNode())
	{
		auto b = getLocalBounds().removeFromTop(UIValues::ZoomOffset).toFloat();

		g.setColour(Colours::black.withAlpha(0.1f));
		g.fillRoundedRectangle(b.reduced(2.0f), 3.0f);

		g.setColour(Colours::white);
		g.setFont(GLOBAL_BOLD_FONT().withHeight(16.0));

		auto& hm = getCurrentRootNode()->getHelpManager();

		auto hb = hm.getHelpSize().toFloat();

		if(!hb.isEmpty())
		{
			auto nb = root->getBoundsInParent().toFloat();

			if(hm.isHelpBelow())
				hb.setPosition(nb.getBottomLeft());
			else
				hb.setPosition(nb.getTopRight());

			hm.render(g, hb);
		}
		
		
	}

	

	float HoverAlpha = 0.5f;
	
	if (Component::isMouseButtonDownAnywhere())
		HoverAlpha += 0.1f;

	if (network->isFrozen())
		return;

	Array<ParameterSlider*> targetSlidersWithCable;

	if (dragOverlay.alpha != 0.0f)
	{
		g.saveState();
		Array<ParameterSlider*> pSliders;

		fillChildComponentList(pSliders, this);

		for (auto& s : pSliders)
		{
			auto a = getLocalArea(s, s->getLocalBounds()).reduced(1);
			g.excludeClipRegion(a);
		}

		g.fillAll(Colour(0xff1d1d1d).withAlpha(JUCE_LIVE_CONSTANT_OFF(0.4f) * hmath::pow(dragOverlay.alpha, 1.5f)));
		g.restoreState();
	}

	jassert(!findParentComponentOfClass<ZoomableViewport>()->swapImage.isValid());

	Array<DragAndDropContainer::DragImageComponentBase*> draggers;
	fillChildComponentList(draggers, this);

	for (auto e : draggers)
	{
		auto mousePoint = this->getMouseXYRelative().toFloat();

		Rectangle<float> a(mousePoint, mousePoint);

		auto start = getCircle(e->getDetails().sourceComponent, false);
		auto end = a.withSize(start.getWidth(), start.getHeight());

		GlobalHiseLookAndFeel::paintCable(g, start, end, Colours::white, 0.6f);
	}

	Array<ModulationSourceBaseComponent*> modSourceList;
	fillChildComponentList(modSourceList, this);

	float alpha = showCables ? 1.0f : 0.1f;

	Array<ParameterSlider*> sliderList;
	Array<ParameterSlider*> connectedSliders;
	
	fillChildComponentList(sliderList, this);

	Array<MultiOutputDragSource*> multiOutputList;
	fillChildComponentList(multiOutputList, this);

	Array<MacroParameterSlider*> hoveredMacros;
	Array<ModulationSourceBaseComponent*> hoveredModSources;
	Array<MultiOutputDragSource*> hoveredDragSources;

	auto addDragSource = [&](ParameterSlider* sliderToCheck)
	{
		auto isCableNode = dynamic_cast<InterpretedCableNode*>(sliderToCheck->parameterToControl->parent);

		if (isCableNode)
		{
			if (auto nc = sliderToCheck->findParentComponentOfClass<NodeComponent>())
			{
				Component::callRecursive<MultiOutputDragSource>(nc, [&](MultiOutputDragSource* msc)
				{
					hoveredDragSources.add(msc);
					return false;
				});
			}
		}
	};

	auto addModSource = [&](ParameterSlider* sliderToCheck)
	{
		auto isCableNode = dynamic_cast<InterpretedCableNode*>(sliderToCheck->parameterToControl->parent);

		if (isCableNode)
		{
			if (auto nc = sliderToCheck->findParentComponentOfClass<NodeComponent>())
			{
				Component::callRecursive<ModulationSourceBaseComponent>(nc, [&](ModulationSourceBaseComponent* msc)
				{
					hoveredModSources.add(msc);
					return true;
				});
			}
		}
	};

	if (!showCables)
	{
		auto hoveredComponent = Desktop::getInstance().getMainMouseSource().getComponentUnderMouse();

		auto hoveredMacro = dynamic_cast<MacroParameterSlider*>(hoveredComponent);

		if (hoveredMacro == nullptr && hoveredComponent != nullptr)
			hoveredMacro = hoveredComponent->findParentComponentOfClass<MacroParameterSlider>();

		if (hoveredMacro != nullptr)
			hoveredMacros.add(hoveredMacro);

		if (auto hoveredModSource = dynamic_cast<ModulationSourceBaseComponent*>(hoveredComponent))
			hoveredModSources.add(hoveredModSource);

		if (auto hoveredDragSource = dynamic_cast<MultiOutputDragSource*>(hoveredComponent))
			hoveredDragSources.add(hoveredDragSource);
	}

	for (auto sourceSlider : sliderList)
	{
		if (sourceSlider->parameterToControl == nullptr)
			continue;

		if (probeSelectionEnabled || sourceSlider->parameterToControl->isProbed)
		{
			auto b = getLocalArea(sourceSlider, sourceSlider->getLocalBounds()).reduced(1).toFloat();

			float alpha = 0.0f;

			if (probeSelectionEnabled)
			{
				g.setColour(Colours::white.withAlpha(0.06f));
				g.fillRoundedRectangle(b, 5.0f);
				alpha += 0.05f;
			}

			if (sourceSlider->parameterToControl->isProbed)
				alpha += 0.3f;

			Path p;
			p.loadPathFromData(ScriptnodeIcons::probeIcon, sizeof(ScriptnodeIcons::probeIcon));
			auto top = b.removeFromRight(17.0f).removeFromTop(17.0f).reduced(2.0f);
			PathFactory::scalePath(p, top);
			g.setColour(Colours::white.withAlpha(alpha));
			g.fillPath(p);
		}

		auto cableColour = getSpecialColour(sourceSlider, Colour(MIDI_PROCESSOR_COLOUR));
		
		if (auto macro = dynamic_cast<NodeContainer::MacroParameter*>(sourceSlider->parameterToControl.get()))
		{
			auto isActiveMacro = false;

			if (!showCables)
			{
				for (auto& hv : hoveredMacros)
				{
					if (hv->getParameter() == macro)
					{
						isActiveMacro = true;
						break;
					}
				}
			}

			for (auto targetSlider : sliderList)
			{
				auto target = targetSlider->parameterToControl;

				if (target == nullptr || !target->parent->isBodyShown())
					continue;

				if (macro->isConnectedToSource(target))
				{
					auto colourToUse = cableColour;

					if (auto nc = targetSlider->findParentComponentOfClass<NodeComponent>())
					{
						colourToUse = nc->getHeaderColour();
					}

					auto start = getCircle(sourceSlider);
					auto end = getCircle(targetSlider);

					connectedSliders.add(targetSlider);

					Colour hc = targetSlider->isMouseOver(true) ? Colours::red : Colour(0xFFAAAAAA);

					float thisAlpha = alpha;

					if (isActiveMacro)
					{
						if (auto newHv = targetSlider->findParentComponentOfClass<MacroParameterSlider>())
							hoveredMacros.add(newHv);

						thisAlpha = HoverAlpha;

						addModSource(targetSlider);
						addDragSource(targetSlider);
					}
                    
                    if(!showCables && targetSlider->isMouseOverOrDragging(true))
                        thisAlpha = HoverAlpha;
					
					GlobalHiseLookAndFeel::paintCable(g, start, end, colourToUse, thisAlpha, hc);

					targetSlidersWithCable.addIfNotAlreadyThere(targetSlider);
				}
			}
		}
	}

	for (auto multiSource : multiOutputList)
	{
		if (!multiSource->getNode()->isBodyShown())
			continue;

		auto isHovered = !showCables && hoveredDragSources.contains(multiSource);

		for (auto s : sliderList)
		{
			if (!s->node->isBodyShown())
				continue;

			if (multiSource->matchesParameter(s->parameterToControl))
			{
				float thisAlpha = alpha;
				
				if (isHovered)
				{
					addModSource(s);
					addDragSource(s);
					thisAlpha = HoverAlpha;
				}

				connectedSliders.add(s);

				auto start = getCircle(multiSource->asComponent(), false);
				auto end = getCircle(s);

				auto index = multiSource->getOutputIndex();
				auto numOutputs = multiSource->getNumOutputs();
				auto c = MultiOutputDragSource::getFadeColour(index, numOutputs).withAlpha(1.0f);

                if(!showCables && s->isMouseOver(true))
                {
                    thisAlpha = HoverAlpha;
                }
                
				Colour hc = s->isMouseOver(true) ? Colours::red : Colour(0xFFAAAAAA);
				auto midPoint = GlobalHiseLookAndFeel::paintCable(g, start, end, c, thisAlpha, hc, network->getCpuProfileFlag());

				targetSlidersWithCable.addIfNotAlreadyThere(s);

				if (!midPoint.isOrigin())
				{
					drawBlockrateForCable(g, midPoint, c, thisAlpha, multiSource->getNode(), s->node);
				}
			}
		}
	}

	

	for (auto modSource : modSourceList)
	{
		float thisAlpha = alpha;
		bool isActiveModSource = !showCables && hoveredModSources.contains(modSource);

		if (isActiveModSource)
			thisAlpha = HoverAlpha;

		auto start = getCircle(modSource, false);

		auto cableColour = getSpecialColour(modSource, Colour(0xffbe952c));

		if (auto sourceNode = modSource->getSourceNodeFromParent())
		{
			if (!sourceNode->isBodyShown())
				continue;

			auto modTargets = sourceNode->getModulationTargetTree();

			for (auto c : modTargets)
			{
				for (auto s : sliderList)
				{
					if (s->parameterToControl == nullptr)
						continue;

					if (!s->parameterToControl->parent->isBodyShown())
						continue;

					auto parentMatch = s->parameterToControl->parent->getId() == c[PropertyIds::NodeId].toString();
					auto paraMatch = s->parameterToControl->getId() == c[PropertyIds::ParameterId].toString();

					if (parentMatch && paraMatch)
					{
						if (isActiveModSource)
						{
							addModSource(s);
						}

						connectedSliders.add(s);

						auto end = getCircle(s);

                        if(!showCables && s->isMouseOver(true))
                        {
                            thisAlpha = HoverAlpha;
                        }
                        
						Colour hc = s->isMouseOver(true) ? Colours::red : Colour(0xFFAAAAAA);

						auto midPoint = GlobalHiseLookAndFeel::paintCable(g, start, end, cableColour, thisAlpha, hc, network->getCpuProfileFlag());

						targetSlidersWithCable.addIfNotAlreadyThere(s);

						if (!midPoint.isOrigin())
						{
							auto thisSource = ConnectionBase::Helpers::findRealSource(sourceNode);
							auto thisTarget = ConnectionBase::Helpers::findRealSource(s->parameterToControl->parent);

							if(thisSource != nullptr && thisTarget != nullptr)
								drawBlockrateForCable(g, midPoint, cableColour, thisAlpha, thisSource, thisTarget);
						}

						auto drawSiblingCables = s->node->isClone() && !sourceNode->isClone();

						if (drawSiblingCables)
						{
							auto root = s->node->findParentNodeOfType<CloneNode>();

							CloneNode::CloneIterator cit(*root, s->parameterToControl->data, true);

							auto numClones = root->getParameterFromIndex(0)->getValue();
							int i = 0;

							for (const auto& cv : cit)
							{
								for (const auto& cs : sliderList)
								{
									if (cs->parameterToControl->data == cv)
									{
										auto cend = getCircle(cs);
										GlobalHiseLookAndFeel::paintCable(g, start, cend, i++ < numClones ? cableColour : Colours::grey, thisAlpha * 0.1f, hc);
									}
								}
							}
						}

						break;
					}
				}
			}
		}

	}

	Array<NodeComponent::Header*> bypassList;
	fillChildComponentList(bypassList, this);

	for (auto b : bypassList)
	{
		auto n = b->parent.node.get();

		if (n == nullptr)
			continue;

		if (!n->isBodyShown())
			continue;

		auto connection = n->getDynamicBypassSource(false);

		if (connection.isNotEmpty())
		{
			

			if (connection.contains("["))
			{
				auto nodeId = connection.upToFirstOccurrenceOf("[", false, false);
				auto slotIndex = connection.fromFirstOccurrenceOf("[", false, false).getIntValue();

				for (auto multiSource : multiOutputList)
				{
					if (!multiSource->getNode()->isBodyShown())
						continue;

					if (multiSource->getNode()->getId() == nodeId)
					{
						if (multiSource->getOutputIndex() == slotIndex)
						{
							auto start = getCircle(multiSource->asComponent(), false);
							auto end = getCircle(&b->powerButton).translated(0.0, -60.0f);

							auto c = n->isBypassed() ? Colours::grey : Colour(SIGNAL_COLOUR).withAlpha(0.8f);

							Colour hc = b->isMouseOver(true) ? Colours::red : Colour(0xFFAAAAAA);

							GlobalHiseLookAndFeel::paintCable(g, start, end, c, alpha, hc);
						}
					}
				}
			}
			else
			{
				auto nodeId = connection.upToFirstOccurrenceOf(".", false, false);
				auto pId = connection.fromFirstOccurrenceOf(".", false, false);

				for (auto sourceSlider : sliderList)
				{
					auto c = n->isBypassed() ? Colours::grey : Colour(SIGNAL_COLOUR).withAlpha(0.8f);

					c = getSpecialColour(sourceSlider, c);

					if (sourceSlider->parameterToControl == nullptr)
						continue;

					if (!sourceSlider->parameterToControl->parent->isBodyShown())
						continue;

					if (sourceSlider->parameterToControl->getId() == pId &&
						sourceSlider->parameterToControl->parent->getId() == nodeId)
					{
						auto start = getCircle(sourceSlider);
						auto end = getCircle(&b->powerButton).translated(0.0, -60.0f);
						
						Colour hc = sourceSlider->isMouseOver(true) ? Colours::red : Colour(0xFFAAAAAA);

						GlobalHiseLookAndFeel::paintCable(g, start, end, c, alpha, hc);
						break;
					}
				}
			}
		}
	}

	for(auto s: sliderList)
	{
		if(!s->pTree[PropertyIds::Automated])
			continue;

		if(connectedSliders.contains(s))
			continue;

		if(s->pTree.getParent().getParent()[PropertyIds::Folded])
			continue;

		auto area = getCircle(s);

		auto hover = s->isMouseOver(true);

		g.setColour(hover ? Colours::red : Colours::white);
		g.fillEllipse(area);

		if(hover)
		{
			auto ct = s->getConnectionSourceTree();

			auto nt = valuetree::Helpers::findParentWithType(ct, PropertyIds::Node);

			if(auto sn = network->getNodeForValueTree(nt))
			{
				NodeComponent* nb = nullptr;

				while(nb == nullptr)
				{
					for(auto b: bypassList)
					{
						if(b->parent.node.get() == sn)
						{
							nb = &b->parent;
							break;
						}
					}

					sn = sn->getParentNode();

					if(sn == nullptr)
						break;
				}

				if(nb != nullptr)
				{
					auto notFolded = true;

					while(notFolded)
					{
						auto nt = nb->node->getValueTree().getParent();

						valuetree::Helpers::forEachParent(nt, [&](const ValueTree& p)
						{
							if(p.getType() == PropertyIds::Node)
							{
								notFolded &= !(bool)p[PropertyIds::Folded];
							}

							return false;
						});

						if(notFolded)
							break;

						nb = nb->findParentComponentOfClass<NodeComponent>();

						if(nb == nullptr)
							break;
					}

					if(nb != nullptr)
					{
						auto h = &nb->header;

						auto sourceRect = getLocalArea(h, h->getLocalBounds());

						g.setColour(Colours::red.withAlpha(0.2f));
						g.fillRect(sourceRect);
						
					}

					break;
				}
			}
		}

		
	}

	Array<cable::dynamic::editor*> sendList;
	fillChildComponentList(sendList, this);

	for (auto s : sendList)
	{
		auto nc = s->findParentComponentOfClass<NodeComponent>();

		auto c = getSpecialColour(s, Colours::white);


		if (!nc->node->isBodyShown())
			continue;

		if (auto sn = s->getAsSendNode())
		{
			for (auto r : sendList)
			{
				nc = r->findParentComponentOfClass<NodeComponent>();

				if (!nc->node->isBodyShown())
					continue;

				if (auto rn = r->getAsReceiveNode())
				{
					if (&sn->cable == rn->source)
					{
						auto start = getCircle(s, false);
						auto end = getCircle(r, false);

						Colour hc = r->isMouseOver(true) ? Colours::red : Colour(0xFFAAAAAA);

						GlobalHiseLookAndFeel::paintCable(g, start, end, c, alpha, hc);
					}
				}
			}
		}
	}

	Array<LockedContainerExtraComponent*> lockedContainers;
	fillChildComponentList(lockedContainers, this);

	for(auto& c: lockedContainers)
	{
		if(c->getObject()->getValueTree()[PropertyIds::Folded])
			continue;

		for(const auto& ev: c->externalConnections)
		{
			auto typeId = ev.getParent().getParent().getType();

			if(typeId == PropertyIds::Parameter)
			{
				for(auto p: sliderList)
				{
					if(ev.isAChildOf(p->pTree))
					{
						auto start = getCircle(p, true);
						auto end = getCircle(c, false);

						auto t = network->getNodeWithId(ev[PropertyIds::NodeId].toString());

						auto c = t->getColour();

						if(c.isTransparent())
							c = Colours::white;

						GlobalHiseLookAndFeel::paintCable(g, start, end, c, 0.5f);
						break;
;					}
				}
			}
			else
			{
				bool found = false;

				for(auto m: modSourceList)
				{
					if(ev.isAChildOf(m->getSourceNodeFromParent()->getValueTree()))
					{
						auto start = getCircle(m, false);
						auto end = getCircle(c, false);

						auto t = network->getNodeWithId(ev[PropertyIds::NodeId].toString());

						auto c = t->getColour();

						GlobalHiseLookAndFeel::paintCable(g, start, end, c, alpha * 0.5f);
						found = true;
						break;
					}
				}

				if(!found)
				{
					for(auto m: multiOutputList)
					{
						if(ev.isAChildOf(m->getNode()->getValueTree()))
						{
							auto evParent = ev.getParent().getParent();
							jassert(evParent.getType() == PropertyIds::SwitchTarget);
							auto connectionIndex = evParent.getParent().indexOf(evParent);

							if(connectionIndex == m->getOutputIndex())
							{
								auto start = getCircle(dynamic_cast<Component*>(m), false);
								auto end = getCircle(c, false);

								auto t = network->getNodeWithId(ev[PropertyIds::NodeId].toString());

								auto c = MultiOutputDragSource::getFadeColour(connectionIndex, m->getNumOutputs()).withAlpha(1.0f);
								
								GlobalHiseLookAndFeel::paintCable(g, start, end, c, alpha * 0.5f);
								break;
							}
						}
					}

				}
			}
		}
	}
	
	if(!isShowingRootNode())
	{
		for(auto p: sliderList)
		{
			if(p->pTree[PropertyIds::Automated] && !targetSlidersWithCable.contains(p))
			{
				auto source = p->getConnectionSourceTree();

				auto typeId = source.getParent().getParent().getType();

				// Do not show the connections to the current breadcrumb...
				if(source.isAChildOf(getCurrentRootNode()->getValueTree()))
					continue;

				for(auto bc: breadcrumbs)
				{
					if(source.isAChildOf(bc->node->getValueTree()))
					{
						auto start = getCircle(bc, false).translated(0.0, JUCE_LIVE_CONSTANT(0.0f));
						auto end = getCircle(p);

						auto colourToUse = Colours::white;

						
						if(typeId == PropertyIds::Parameter)
						{
							// Use the target node colour for the cable when connected to a parameter
							if (auto nc = p->findParentComponentOfClass<NodeComponent>())
								colourToUse = nc->getHeaderColour();

						}
						else if(typeId == PropertyIds::SwitchTarget)
						{
							// use the multi out colour for the given output index
							auto st = valuetree::Helpers::findParentWithType(source, PropertyIds::SwitchTarget);
							auto numOutputs = st.getParent().getNumChildren();
							auto index = st.getParent().indexOf(st);
							colourToUse = MultiOutputDragSource::getFadeColour(index, numOutputs).withAlpha(1.0f);
						}
						else
						{
							// Use the source node for modulation outputs
							auto c = valuetree::Helpers::findParentWithType(source, PropertyIds::Node)[PropertyIds::NodeColour];
							colourToUse = PropertyHelpers::getColourFromVar(c);
						}

						GlobalHiseLookAndFeel::paintCable(g, start, end, colourToUse, alpha);
						break;
					}
				}
			}
		}
	}

	if(isMouseButtonDown(true) || externalDragComponent)
	{
		auto currentComponent = externalDragComponent != nullptr ? externalDragComponent : Desktop::getInstance().getMainMouseSource().getComponentUnderMouse();
		
		auto dragSourceIsValid = [](Component* c)
		{
			if(dynamic_cast<ModulationSourceBaseComponent*>(c))
				return true;

			if(auto ps = dynamic_cast<MacroParameterSlider::Dragger*>(c))
			{
				return ps->parent.dragging;
			}

			if(auto ps = dynamic_cast<BreadcrumbButton*>(c))
				return ps->draggingIndex != -1;

			if(dynamic_cast<MultiOutputDragSource*>(c))
				return true;

			return false;
		};

		if(!dragSourceIsValid(currentComponent))
			return;

		auto currentPosition = getMouseXYRelative().toFloat();

		auto start = getCircle(currentComponent, false);

		if(auto d = dynamic_cast<MacroParameterSlider::Dragger*>(currentComponent))
		{
			start = getCircle(d->getCircleComponent(), true);
		}

		auto alpha = 0.3f;

		auto end = Rectangle<float>(currentPosition, currentPosition).withSizeKeepingCentre(start.getWidth(), start.getHeight());

		auto c1 = Colours::white;
		Colour c2 = c1;

		bool hanging = false;

		if(auto ps = dynamic_cast<ParameterSlider*>(getComponentAt(currentPosition)))
		{
			DragAndDropTarget::SourceDetails d(var(), currentComponent, {});
			auto ok = ps->isInterestedInDragSource(d);

			c2 = ok ? Colour(SIGNAL_COLOUR) : Colour(HISE_ERROR_COLOUR);

			if(ok)
			{
				end = getCircle(ps, true);
				currentPosition = end.getCentre();
				hanging = true;
			}

			alpha = 1.0f;
		}

		float dragSmoothAlpha = JUCE_LIVE_CONSTANT_OFF(0.4f);
		float maxValue = JUCE_LIVE_CONSTANT_OFF(20.0f);

		Point<float> delta = currentPosition - lastMousePos;

		Range<float> cd(-maxValue, maxValue);

		delta.setX(cd.clipValue(currentPosition.getX() - lastMousePos.getX()));
		delta.setY(cd.clipValue(currentPosition.getY() - lastMousePos.getY()));

		auto fadeAlpha = jlimit(0.0f, 1.0f, 1.0f - delta.getDistanceFromOrigin() / 30.0f);

		auto c = c2;

		

		GlobalHiseLookAndFeel::paintCable(g, start, end, c, alpha, c, false, hanging, delta);

		lastMousePos.setX(lastMousePos.getX() * dragSmoothAlpha + currentPosition.getX() * (1.0f - dragSmoothAlpha));
		lastMousePos.setY(lastMousePos.getY() * dragSmoothAlpha + currentPosition.getY() * (1.0f - dragSmoothAlpha));
	}

	
}

scriptnode::NodeComponent* DspNetworkGraph::getComponent(NodeBase::Ptr node)
{
	Array<NodeComponent*> nodes;
	fillChildComponentList(nodes, this);

	for (auto nc : nodes)
		if (nc->node.get() == node.get())
			return nc;

	return nullptr;
}

bool DspNetworkGraph::setCurrentlyDraggedComponent(NodeComponent* n)
{
	if (auto parentContainer = dynamic_cast<NodeDropTarget*>(n->getParentComponent()))
	{
		n->setBufferedToImage(true);
		auto b = n->getLocalArea(parentContainer->asComponent(), n->getBounds());
		parentContainer->removeDraggedNode(n);
		addAndMakeVisible(currentlyDraggedComponent = n);

		n->setBounds(b);
		return true;
	}

	return false;
}




void DspNetworkGraph::Actions::selectAndScrollToNode(DspNetworkGraph& g, NodeBase::Ptr node)
{
	auto p = node->getValueTree();

	while (p.getType() != PropertyIds::Network && p.isValid())
	{
		if (p.getType() == PropertyIds::Node)
			p.setProperty(PropertyIds::Folded, false, node->getUndoManager());

		p = p.getParent();
	}

	g.network->deselectAll();
	g.network->addToSelection(node, {});
	
	auto parent = g.findParentComponentOfClass<ZoomableViewport>();
	auto selection = g.network->getSelection();

	RectangleList<int> nBounds;
	Array<NodeComponent*> list;

	fillChildComponentList(list, &g);

	for (auto nc : list)
	{
		if (selection.contains(nc->node.get()))
		{
			auto b = g.getLocalArea(nc, nc->getLocalBounds());
			nBounds.addWithoutMerging(b);
		}
	}

	auto selectionBounds = nBounds.getBounds().expanded(UIValues::NodeMargin);

	parent->zoomToRectangle(selectionBounds.expanded(300));
	g.repaint();
	g.grabKeyboardFocus();
}

bool DspNetworkGraph::Actions::swapOrientation(DspNetworkGraph& g)
{
	auto l = g.network->getSelection();

	for (auto n : l)
	{
		if(auto sn = dynamic_cast<SerialNode*>(n.get()))
		{
			sn->isVertical.storeValue(!sn->isVertical.getValue(), sn->getUndoManager());

			auto dg = &g;

			auto f = [sn, dg]()
			{
				if(auto b = dg->getComponent(sn))
				{
					auto cb = dg->getLocalArea(b, b->getLocalBounds());
					dg->findParentComponentOfClass<ZoomableViewport>()->zoomToRectangle(cb);
				}
			};

			MessageManager::callAsync(f);

			return true;
		}
	}

	

	return true;
}

bool DspNetworkGraph::Actions::freezeNode(NodeBase::Ptr node)
{
#if 0
	auto freezedId = node->getValueTree()[PropertyIds::FreezedId].toString();

	if (freezedId.isNotEmpty())
	{
		if (auto fn = dynamic_cast<NodeBase*>(node->getRootNetwork()->get(freezedId).getObject()))
		{
			node->getRootNetwork()->deselect(fn);

			auto newTree = fn->getValueTree();
			auto oldTree = node->getValueTree();
			auto um = node->getUndoManager();

			auto f = [oldTree, newTree, um]()
			{
				auto p = oldTree.getParent();

				int position = p.indexOf(oldTree);
				p.removeChild(oldTree, um);
				p.addChild(newTree, position, um);
			};

			MessageManager::callAsync(f);

			auto nw = node->getRootNetwork();
			auto s = [newTree, nw]()
			{
				auto newNode = nw->getNodeForValueTree(newTree);
				nw->deselectAll();
				nw->addToSelection(newNode, ModifierKeys());
			};

			MessageManager::callAsync(s);
		}

		return true;
	}

	auto freezedPath = node->getValueTree()[PropertyIds::FreezedPath].toString();

	if (freezedPath.isNotEmpty())
	{
		auto newNode = node->getRootNetwork()->create(freezedPath, node->getId() + "_freezed");

		if (auto nn = dynamic_cast<NodeBase*>(newNode.getObject()))
		{
			auto newTree = nn->getValueTree();
			auto oldTree = node->getValueTree();
			auto um = node->getUndoManager();

			auto f = [oldTree, newTree, um]()
			{
				auto p = oldTree.getParent();

				int position = p.indexOf(oldTree);
				p.removeChild(oldTree, um);
				p.addChild(newTree, position, um);
			};

			MessageManager::callAsync(f);

			auto nw = node->getRootNetwork();
			auto s = [newTree, nw]()
			{
				auto newNode = nw->getNodeForValueTree(newTree);
				nw->deselectAll();
				nw->addToSelection(newNode, ModifierKeys());
			};

			MessageManager::callAsync(s);
		}

		return true;
	}
#endif

	return false;
}

bool DspNetworkGraph::Actions::unfreezeNode(NodeBase::Ptr node)
{
	if (auto fn = node->getEmbeddedNetwork())
	{
		auto newTree = fn->getRootNode()->getValueTree();
        
        Array<DspNetwork::IdChange> changes;
        
		newTree = node->getRootNetwork()->cloneValueTreeWithNewIds(newTree, changes, true);

		{
			auto oldTree = node->getValueTree();
			auto um = node->getUndoManager();

			auto newNode = node->getRootNetwork()->createFromValueTree(true, newTree, true);

			auto f = [oldTree, newTree, um]()
			{
				auto p = oldTree.getParent();

				int position = p.indexOf(oldTree);
				p.removeChild(oldTree, um);
				p.addChild(newTree, position, um);
			};

			MessageManager::callAsync(f);

			auto nw = node->getRootNetwork();

			auto s = [newNode, nw]()
			{
				nw->deselectAll();
				nw->addToSelection(newNode, ModifierKeys());
			};

			MessageManager::callAsync(s);
		}
	}

	return false;
}

bool DspNetworkGraph::Actions::toggleBypass(DspNetworkGraph& g)
{
	auto selection = g.network->getSelection();

	if (selection.isEmpty())
		return false;

	bool oldState = selection.getFirst()->isBypassed();

	for (auto n : selection)
	{
		n->setBypassed(!oldState);
	}

	return true;
}

bool DspNetworkGraph::Actions::toggleSignalDisplay(DspNetworkGraph& g)
{
    auto shouldBeOn = !g.network->isSignalDisplayEnabled();
    
    g.network->setSignalDisplayEnabled(shouldBeOn);
    
    Component::callRecursive<ContainerComponent>(&g, [shouldBeOn](ContainerComponent* c)
    {
        if(shouldBeOn)
            c->start();
        else
            c->stop();
        
        c->repaint();
        return false;
    });
    
    return true;
}

bool DspNetworkGraph::Actions::toggleFreeze(DspNetworkGraph& g)
{
	auto selection = g.network->getSelection();

	if (selection.isEmpty())
	{
		if (g.network->canBeFrozen())
			g.network->setUseFrozenNode(!g.network->isFrozen());

		g.repaint();

		return true;
	}
	else
	{
		auto f = selection.getFirst();


		if (auto fn = f->getEmbeddedNetwork())
		{
			if (fn->canBeFrozen())
			{
				auto state = !fn->isFrozen();

				for (auto s : selection)
					s->setValueTreeProperty(PropertyIds::Frozen, state);
			}
		}

		return true;
	}
		
	return false;
}



bool DspNetworkGraph::Actions::save(DspNetworkGraph& g)
{
#if USE_BACKEND
    auto saveCopy = g.network->getValueTree().createCopy();

	DspNetworkListeners::PatchAutosaver::removeDanglingConnections(saveCopy);

    valuetree::Helpers::forEach(saveCopy, DspNetworkListeners::PatchAutosaver::stripValueTree);

    auto xml = saveCopy.createXml();

    auto folder = BackendDllManager::getSubFolder(g.network->getScriptProcessor()->getMainController_(), BackendDllManager::FolderSubType::Networks);
    
    auto d = folder.getChildFile(g.network->getId()).withFileExtension("xml");
    
    if(!d.existsAsFile() || PresetHandler::showYesNoWindow("Overwrite file", "Do you want to overwrite the file " + d.getFullPathName()))
    {
        d.replaceWithText(xml->createDocument(""));
    }
	
#endif

    return true;
}



bool DspNetworkGraph::Actions::exportAsSnippet(DspNetworkGraph& g)
{
    jassertfalse;
    return true;
}


bool DspNetworkGraph::Actions::toggleProbe(DspNetworkGraph& g)
{
	g.toggleProbeMode();
	return true;
}

bool DspNetworkGraph::Actions::setRandomColour(DspNetworkGraph& g)
{
	auto selection = g.network->getSelection();

	auto sat = JUCE_LIVE_CONSTANT_OFF(0.5f);
	auto br = JUCE_LIVE_CONSTANT_OFF(0.7f);

	auto c = Colour::fromHSV(Random::getSystemRandom().nextFloat(), sat, br, 1.0f);
	auto v = (int64)c.getARGB();

	for (auto n : selection)
	{
		n->getValueTree().setProperty(PropertyIds::NodeColour, v, g.network->getUndoManager());
	}

	return true;
}

#if USE_BACKEND
struct PopupCodeProvider : public snex::ui::WorkbenchData::CodeProvider
{
	PopupCodeProvider(WorkbenchData* d, DspNetwork* n) :
		CodeProvider(d),
		networkId(n->getId())
	{}

	String loadCode() const override
	{
		return {};
	}

	bool providesCode() const override { return false; }

	bool saveCode(const String& s) override { return true; }

	/** Override this method and return the instance id. This will be used to find the main class in nodes. */
	virtual Identifier getInstanceId() const override { return networkId; }

	Identifier networkId;
};

struct PopupCompileHandler : public ScriptnodeCompileHandlerBase,
	public valuetree::AnyListener
{
	PopupCompileHandler(WorkbenchData* d, DspNetwork* n) :
		ScriptnodeCompileHandlerBase(d, n)
	{
		setRootValueTree(n->getValueTree());
		setMillisecondsBetweenUpdate(500);
		d->getTestData().setTestRootDirectory(BackendDllManager::getSubFolder(n->getScriptProcessor()->getMainController_(), BackendDllManager::FolderSubType::Tests));
	}

	~PopupCompileHandler()
	{
		if (network->isBeingDebugged())
			network->getParentHolder()->toggleDebug();
	}

	void anythingChanged(CallbackType) override
	{
		getParent()->triggerPostCompileActions();
	}

	PrepareSpecs getPrepareSpecs() const override
	{
		return network->getCurrentSpecs();
	}
};

using namespace snex::ui;



struct ScriptnodeDebugPopup: public Component,
							 public ControlledObject,
							 public Timer
{
	ScriptnodeDebugPopup(MainController* mc, snex::ui::WorkbenchData::Ptr p, DspNetwork* n):
		ControlledObject(mc),
		dbgNetwork(n),
		wb(p),
		root(mc, nullptr),
		resizer(this, nullptr)
	{
		setName("Scriptnode Debugger");
		FloatingInterfaceBuilder builder(&root);

		auto& wbManager = dynamic_cast<BackendProcessor*>(mc)->workbenches;
		
		prevWb = wbManager.getCurrentWorkbench();
		wbManager.setCurrentWorkbench(wb, false);

		builder.setNewContentType<HorizontalTile>(0);
		int testTab = 0;

		auto pl = builder.addChild<SnexWorkbenchPanel<snex::ui::TestDataComponent>>(testTab);
		auto uig = builder.addChild<SnexWorkbenchPanel<snex::ui::TestGraph>>(testTab);
		builder.addChild<WorkbenchTestPlayer>(testTab);

		builder.setCustomName(pl, "Test Input");
		builder.setCustomName(uig, "Test Signal Analyser");
		builder.setCustomName(uig, "Test Signal Player");

		builder.setDynamic(testTab, false);
		builder.setSizes(testTab, { -0.3, -0.7, -0.3 });

		addAndMakeVisible(builder.finalizeAndReturnRoot());
		addAndMakeVisible(resizer);
		setSize(700, 450);
		startTimer(100);
        
        wb->triggerRecompile();
	}

	~ScriptnodeDebugPopup()
	{
		dynamic_cast<BackendProcessor*>(getMainController())->workbenches.setCurrentWorkbench(prevWb, true);
		prevWb = nullptr;
		wb = nullptr;
	}

	void resized() override
	{
		root.setBounds(getLocalBounds());
		resizer.setBounds(getLocalBounds().removeFromBottom(15).removeFromRight(15));
	}

	void timerCallback() override
	{
		if (dbgNetwork == nullptr || !dbgNetwork->isBeingDebugged())
		{
			findParentComponentOfClass<FloatingTilePopup>()->deleteAndClose();
		}
	}

	snex::ui::WorkbenchData::Ptr prevWb;

	WeakReference<DspNetwork> dbgNetwork;
	snex::ui::WorkbenchData::Ptr wb;
	FloatingTile root;
	juce::ResizableCornerComponent resizer;
};
#endif

bool DspNetworkGraph::Actions::toggleDebug(DspNetworkGraph& g)
{
#if USE_BACKEND
	g.network->getParentHolder()->toggleDebug();

	if (auto dbg = g.network->getParentHolder()->getDebuggedNetwork())
	{
        auto w = g.findParentComponentOfClass<FloatingTile>()->getRootFloatingTile();
		

		Array<ActionButton*> list;
		fillChildComponentList(list, g.findParentComponentOfClass<WrapperWithMenuBar>());

		for (auto b : list)
		{
			if (b->getName() == "debug")
			{
                auto wb = new snex::ui::WorkbenchData();
            
                wb->setCompileHandler(new PopupCompileHandler(wb, dbg));
                wb->setCodeProvider(new PopupCodeProvider(wb, dbg));

				w->showComponentInRootPopup(new ScriptnodeDebugPopup(w->getMainController(), wb, dbg), b, { b->getLocalBounds().getCentreX(), b->getHeight() }, false);
				return true;
			}
		}
	}

	g.repaint();
#endif

	return true;
}

bool DspNetworkGraph::Actions::copyToClipboard(DspNetworkGraph& g)
{
	if (auto n = g.network->getSelection().getFirst())
	{
		g.getComponent(n)->handlePopupMenuResult((int)NodeComponent::MenuActions::ExportAsSnippet);
		return true;
	}

	return false;
}

bool DspNetworkGraph::Actions::toggleCableDisplay(DspNetworkGraph& g)
{
	g.showCables = !g.showCables;
	g.repaint();
	return true;
}

bool DspNetworkGraph::Actions::toggleComments(DspNetworkGraph& g)
{
	auto showComments = (bool)g.dataReference[PropertyIds::ShowComments];
	g.dataReference.setProperty(PropertyIds::ShowComments, !showComments, nullptr);
	g.rebuildNodes();
	return true;
}

bool DspNetworkGraph::Actions::toggleCpuProfiling(DspNetworkGraph& g)
{
	auto& b = g.network->getCpuProfileFlag();
	b = !b;
	
	g.enablePeriodicRepainting(b);

	g.repaint();

	return true;
}

bool DspNetworkGraph::Actions::editNodeProperty(DspNetworkGraph& g)
{
	if (auto n = g.network->getSelection().getFirst())
	{
		g.getComponent(n)->handlePopupMenuResult((int)NodeComponent::MenuActions::EditProperties);
		return true;
	}
	else
	{
		auto nn = new PropertyEditor(g.network->getRootNode(), false, g.network->getValueTree(), {PropertyIds::ID, PropertyIds::FactoryPath}, false);

		nn->setName("Edit Network Properties");

		auto z = g.findParentComponentOfClass<ZoomableViewport>();
		auto b = z->getLocalArea(&g, g.getLocalBounds());

		z->setCurrentModalWindow(nn, b);
	}

	return false;
}

bool DspNetworkGraph::Actions::foldSelection(DspNetworkGraph& g)
{
	auto selection = g.network->getSelection();

	if (selection.isEmpty())
		return false;

	auto shouldBeFolded = !(bool)selection.getFirst()->getValueTree()[PropertyIds::Folded];

	for (auto n : selection)
		n->setValueTreeProperty(PropertyIds::Folded, shouldBeFolded);

	return true;
}

bool DspNetworkGraph::Actions::foldUnselectedNodes(DspNetworkGraph& g)
{
    auto selection = g.network->getSelection();
    
    if(selection.isEmpty())
    {
        zoomFit(g);
        return true;
    }
    
	auto parent = g.findParentComponentOfClass<ZoomableViewport>();

	int counter = 0;

	if(g.getCurrentRootNode()->getValueTree().isAChildOf(selection.getFirst()->getValueTree()))
	{
		g.setCurrentRootNode(selection.getFirst());
	}

	auto skipAnimation = valuetree::Helpers::forEach(g.network->getValueTree(), [&](const ValueTree& v)
	{
		if(v.getType() == PropertyIds::Node)
			counter++;

		return counter > 30;
	});

	if(!skipAnimation)
		parent->makeSwapSnapshot(JUCE_LIVE_CONSTANT_OFF(1.005f));

	auto l = g.network->getListOfNodesWithType<NodeBase>(false);
	
	auto isParentNode = [](NodeBase*n, NodeBase* possibleParent)
	{
		if (n == possibleParent)
			return true;

		while (n != nullptr)
		{
			n = n->getParentNode();
			if (n == possibleParent)
				return true;
		}

		return false;
	};

	for (auto n : l)
	{
		bool shouldBeVisible = false;

		for (auto s : selection)
		{
			shouldBeVisible |= isParentNode(s, n);
			shouldBeVisible |= isParentNode(n, s);
		}
			

		if(g.network->getRootNode() != n)
			n->setValueTreeProperty(PropertyIds::Folded, !shouldBeVisible);
	}

	

	auto f = [&g]()
	{
		g.findParentComponentOfClass<ZoomableViewport>()->clearSwapSnapshot();

		auto selection = g.network->getSelection();

		RectangleList<int> nBounds;
		Array<NodeComponent*> list;

		fillChildComponentList(list, &g);

		Array<MacroParameterSlider*> sliderList;

		fillChildComponentList(sliderList, &g);

		for (auto nc : list)
		{
			if (selection.contains(nc->node.get()))
			{
				auto b = g.getLocalArea(nc, nc->getLocalBounds());
				nBounds.addWithoutMerging(b);
			}
		}

		for (auto sl : sliderList)
		{
			if (sl->editEnabled)
			{
				auto b = g.getLocalArea(sl, sl->getLocalBounds());
				nBounds.addWithoutMerging(b);
			}
		}

		auto selectionBounds = nBounds.getBounds().expanded(UIValues::NodeMargin);

		g.findParentComponentOfClass<ZoomableViewport>()->zoomToRectangle(selectionBounds);
		g.repaint();
		g.grabKeyboardFocus();
	};

	if(skipAnimation)
		f();
	else
		Timer::callAfterDelay(JUCE_LIVE_CONSTANT_OFF(300), f);

	return true;
}

bool DspNetworkGraph::Actions::arrowKeyAction(DspNetworkGraph& g, const KeyPress& k)
{
	auto node = g.network->getSelection().getFirst();

	if (node == nullptr || g.network->getSelection().size() > 1)
		return false;

	auto network = g.network;

	bool swapAction = k.getModifiers().isShiftDown();

	if (swapAction)
	{
		auto swapWithPrev = k == KeyPress::upKey;

		auto tree = node->getValueTree();
		auto parent = tree.getParent();
		auto index = node->getIndexInParent();

		if (swapWithPrev)
			parent.moveChild(index, index - 1, node->getUndoManager());
		else
			parent.moveChild(index, index + 1, node->getUndoManager());

		return true;
	}
	else
	{


		auto selectPrev = k == KeyPress::upKey;
		auto index = node->getIndexInParent();

		if (selectPrev)
		{
			auto container = dynamic_cast<NodeContainer*>(node->getParentNode());

			if (container == nullptr)
				return false;

			if (index == 0)
				selectAndScrollToNode(g, node->getParentNode());
			else
			{
				auto prevNode = container->getNodeList()[index - 1];

				if (auto prevContainer = dynamic_cast<NodeContainer*>(prevNode.get()))
				{
					if (auto lastChild = prevContainer->getNodeList().getLast())
					{
						selectAndScrollToNode(g, lastChild);
						return true;
					}
				}

				selectAndScrollToNode(g, prevNode);
				return true;
			}


			return true;
		}
		else
		{
			auto container = dynamic_cast<NodeContainer*>(node.get());

			if (container != nullptr && node->isBodyShown())
			{
				if (auto firstChild = container->getNodeList()[0])
				{
					selectAndScrollToNode(g, firstChild);
					return true;
				}
			}

			container = dynamic_cast<NodeContainer*>(node->getParentNode());

			if (container == nullptr)
				return false;

			if (auto nextSibling = container->getNodeList()[index + 1])
			{
				selectAndScrollToNode(g, nextSibling);
				return true;
			}

			node = node->getParentNode();

			container = dynamic_cast<NodeContainer*>(node->getParentNode());

			if (container == nullptr)
				return false;

			index = node->getIndexInParent();

			if (auto nextSibling = container->getNodeList()[index + 1])
			{
				selectAndScrollToNode(g, nextSibling);
				return true;
			}
		}
	}

	return false;
}

bool DspNetworkGraph::Actions::showKeyboardPopup(DspNetworkGraph& g, KeyboardPopup::Mode)
{
	auto firstInSelection = g.network->getSelection().getFirst();

	NodeBase::Ptr containerToLookFor;

	int addPosition = -1;

	bool somethingSelected = dynamic_cast<NodeContainer*>(firstInSelection.get()) != nullptr;
	bool stillInNetwork = somethingSelected && firstInSelection->getParentNode() != nullptr;


	if (somethingSelected && stillInNetwork)
		containerToLookFor = firstInSelection;
	else if (firstInSelection != nullptr)
	{
		containerToLookFor = firstInSelection->getParentNode();
		addPosition = firstInSelection->getIndexInParent() + 1;
	}

	Array<ContainerComponent*> list;

	fillChildComponentList(list, &g);

	bool mouseOver = g.isMouseOver(true);

	if (mouseOver)
	{
		int hoverPosition = -1;
		NodeBase* hoverContainer = nullptr;

		for (auto nc : list)
		{
			auto thisAdd = nc->getCurrentAddPosition();

			if (thisAdd != -1)
			{
				hoverPosition = thisAdd;
				hoverContainer = nc->node.get();
				break;
			}
		}

		if (hoverPosition != -1)
		{
			containerToLookFor = nullptr;
			addPosition = -1;
		}
	}

	for (auto nc : list)
	{
		auto thisAddPosition = nc->getCurrentAddPosition();


		bool containerIsSelected = nc->node.get() == containerToLookFor.get();
		bool nothingSelectedAndAddPositionMatches = (containerToLookFor == nullptr && thisAddPosition != -1);

		if (containerIsSelected || nothingSelectedAndAddPositionMatches)
		{
			if (addPosition == -1)
				addPosition = thisAddPosition;

			KeyboardPopup* newPopup = new KeyboardPopup(nc->node.get(), addPosition);

			auto midPoint = nc->getInsertRuler(addPosition);

			auto sp = g.findParentComponentOfClass<ZoomableViewport>();

			auto r = sp->getLocalArea(nc, midPoint.toNearestInt());

			auto popupBounds = newPopup->getLocalBounds();

			if(sp->getLocalBounds().reduced(-3).contains(popupBounds))
			{
				sp->setCurrentModalWindow(newPopup, r);
			}
			else
			{
#if USE_BACKEND
				auto bpe = g.findParentComponentOfClass<BackendRootWindow>();

				struct PopupWrapper: public Component,
									 public ModalBaseWindow,
									 public QuasiModalComponent
				{
					PopupWrapper(KeyboardPopup* p):
					  content(p)
					{
						setWantsBackdrop(true, true);
						
						p->parentIsViewport = false;
						addAndMakeVisible(p);
						setSize(p->getWidth(), p->getHeight());
						setName("Add node");
						content->grabKeyboardFocusAsync();
					}

					void paint(Graphics& g) override
					{
						g.fillAll(Colour(0xFF222222));

						auto b = getLocalBounds().toFloat();
						b = b.removeFromTop(24);
						g.setColour(Colours::white.withAlpha(0.8f));

						g.setFont(GLOBAL_BOLD_FONT());
						g.drawText(getName(), b, Justification::centred);
					}

					void resized() override
					{
						auto b = getLocalBounds();
						b.removeFromTop(24);
						content->setBounds(b);
					}

					ScopedPointer<KeyboardPopup> content;
				};

				auto w = new PopupWrapper(newPopup);

				bpe->setModalComponent(w);
#endif
			}

			
		}
	}

	return true;
}




bool DspNetworkGraph::Actions::duplicateSelection(DspNetworkGraph& g)
{
#if USE_BACKEND
	int insertIndex = 0;

	for (auto n : g.network->getSelection())
	{
		auto tree = n->getValueTree();
		insertIndex = jmax(insertIndex, tree.getParent().indexOf(tree) + 1);
	}
	
    Array<DspNetwork::IdChange> changes;
    
    struct TreeData
    {
        ValueTree location;
        ValueTree newTree;
    };
    
    auto sortedSelection = g.network->getSelection();
    
    DuplicateHelpers h;
    
    sortedSelection.sort(h);
    
    Array<TreeData> clonedTrees;
    
	for (auto n : sortedSelection)
	{
		auto tree = n->getValueTree();
        
        TreeData td;
        td.location = tree;
        td.newTree = n->getRootNetwork()->cloneValueTreeWithNewIds(tree, changes, false);
        
		clonedTrees.add(td);
    }
    
    for(auto& ct: clonedTrees)
    {
        for(auto& c: changes)
        {
            g.network->changeNodeId(ct.newTree, c.oldId, c.newId, nullptr);
        }
	}

	Array<ValueTree> newNodes;

	for(auto& ct: clonedTrees)
		newNodes.add(ct.newTree);

	h.removeOutsideConnections(newNodes, changes);

	for(auto& ct: clonedTrees)
	{
		g.network->createFromValueTree(true, ct.newTree, true);
		ct.location.getParent().addChild(ct.newTree, insertIndex, g.network->getUndoManager());
        insertIndex = ct.location.getParent().indexOf(ct.newTree);
	}

    g.network->runPostInitFunctions();

#endif
	return true;
}

bool DspNetworkGraph::Actions::deselectAll(DspNetworkGraph& g)
{
	g.network->deselectAll();

	return true;
}

bool DspNetworkGraph::Actions::deleteSelection(DspNetworkGraph& g)
{
	for (auto n : g.network->getSelection())
	{
		if (n == nullptr)
			continue;

		auto tree = n->getValueTree();
		tree.getParent().removeChild(tree, n->getUndoManager());
	}

	g.network->deselectAll();

	return true;
}

bool DspNetworkGraph::Actions::showJSONEditorForSelection(DspNetworkGraph& g)
{
	Array<var> list;
	NodeBase::List selection = g.network->getSelection();

	if (selection.size() != 1)
		return false;

	for (auto node : selection)
	{
		auto v = ValueTreeConverters::convertScriptNodeToDynamicObject(node->getValueTree());
		list.add(v);
	}

	JSONEditor* editor = new JSONEditor(var(list));

	editor->setEditable(true);

	auto callback = [&g, selection](const var& newData)
	{
		if (auto n = selection.getFirst())
		{
			if (newData.isArray())
			{
				auto newTree = ValueTreeConverters::convertDynamicObjectToScriptNodeTree(newData.getArray()->getFirst());
				n->getValueTree().copyPropertiesAndChildrenFrom(newTree, n->getUndoManager());
			}

		}

		return;
	};

	editor->setCallback(callback, true);
	editor->setName("Editing JSON");
	editor->setSize(400, 400);

	Component* componentToPointTo = &g;

	if (list.size() == 1)
	{
		if (auto fn = g.network->getSelection().getFirst())
		{
			Array<NodeComponent*> ncList;
			fillChildComponentList<NodeComponent>(ncList, &g);

			for (auto nc : ncList)
			{
				if (nc->node.get() == fn.get())
				{
					componentToPointTo = nc;
					break;
				}
			}
		}
	}

	auto p = g.findParentComponentOfClass<ZoomableViewport>();
	auto b = p->getLocalArea(componentToPointTo, componentToPointTo->getLocalBounds());

	p->setCurrentModalWindow(editor, b);

	return true;
}

bool DspNetworkGraph::Actions::lockContainer(DspNetworkGraph& g)
{
	auto list = g.network->getSelection();

	auto firstValue = (bool)list.getFirst()->getValueTree()[PropertyIds::Locked];

	for(auto l: list)
	{
		if(auto c = dynamic_cast<NodeContainer*>(l.get()))
			l->getValueTree().setProperty(PropertyIds::Locked, !firstValue, l->getUndoManager());
	}

	return true;
}

bool DspNetworkGraph::Actions::eject(DspNetworkGraph& g)
{
#if USE_BACKEND
    if(PresetHandler::showYesNoWindow("Unload this network", "Do you want to unload this network?"))
    {
        auto holder = g.network->getParentHolder();
        
        if (auto rootWindow = g.findParentComponentOfClass<BackendRootWindow>())
		{
			auto jsp = dynamic_cast<JavascriptProcessor*>(holder);

			auto gw = [rootWindow, jsp]()
			{
				ReferenceCountedObjectPtr<DspNetwork> pendingDelete;

				pendingDelete = jsp->getActiveOrDebuggedNetwork();

				jsp->unload();
				BackendPanelHelpers::ScriptingWorkspace::setGlobalProcessor(rootWindow, jsp);
				BackendPanelHelpers::showWorkspace(rootWindow, BackendPanelHelpers::Workspace::ScriptingWorkspace, sendNotification);

				pendingDelete = nullptr;
			};

			MessageManager::callAsync(gw);
		}
		else if (auto pc = g.findParentComponentOfClass<PanelWithProcessorConnection>())
		{
			auto p = dynamic_cast<Processor*>(holder);

			auto gw = [pc, p, holder]()
			{
				ReferenceCountedObjectPtr<DspNetwork> pendingDelete;

				pendingDelete = holder->getActiveOrDebuggedNetwork();
				holder->unload();
				pc->setContentWithUndo(p, 0);

				pendingDelete = nullptr;
			};

			MessageManager::callAsync(gw);
		}

        
    }
#endif

	return true;
}

struct ParameterPopup: public Component,
					   public PooledUIUpdater::SimpleTimer
{
	ParameterPopup(DspNetwork* n) :
		SimpleTimer(n->getMainController()->getGlobalUIUpdater()),
		network(n)
	{
		
		setName(n->getId() + " Parameters");

		rebuild({ }, true);
		
		updater.setCallback(n->getRootNode()->getParameterTree(), valuetree::AsyncMode::Asynchronously, BIND_MEMBER_FUNCTION_2(ParameterPopup::rebuild));

		start();
	};

	void timerCallback() override
	{
		if (network == nullptr)
		{
			sliders.clear();
			stop();
			repaint();
			return;
		}


		for(auto s: sliders)
			s->repaint();
	}

	void resized() override
	{
		auto b = getLocalBounds().reduced(0, UIValues::NodeMargin);

		for (auto s : sliders)
			s->setBounds(b.removeFromLeft(128));

		repaint();
	}

	void paint(Graphics& g) override
	{
		if (sliders.isEmpty())
		{
			g.setFont(GLOBAL_BOLD_FONT());
			g.setColour(Colours::white.withAlpha(0.3f));
			g.drawText("No parameters available", getLocalBounds().toFloat(), Justification::centred);
		}
	}

	void rebuild(ValueTree, bool)
	{
		sliders.clear();

		if (network == nullptr)
			return;

		for (int i = 0; i < network->getRootNode()->getNumParameters(); i++)
		{
			addSlider(i);
		}

		setSize(128 * jmax(2, sliders.size()), UIValues::ParameterHeight + 1 * UIValues::NodeMargin);
		resized();
	}

	void addSlider(int index)
	{
		auto ps = new ParameterSlider(network->getRootNode(), index);
		sliders.add(ps);
		addAndMakeVisible(ps);
	}

	OwnedArray<ParameterSlider> sliders;

	WeakReference<DspNetwork> network;
	valuetree::ChildListener updater;
};

bool DspNetworkGraph::Actions::showParameterPopup(DspNetworkGraph& g)
{
	auto s = new ParameterPopup(g.network.get());

	auto ft = g.findParentComponentOfClass<FloatingTile>();

	auto wb = g.findParentComponentOfClass<WrapperWithMenuBar>();

	Component* b = nullptr;

	Component::callRecursive<ActionButton>(wb, [&b](ActionButton* p)
	{
		if (p->getName() == "parameters")
		{
			b = p;
			return true;
		}

		return false;
	});

	if (b == nullptr)
		b = &g;

	if(ft->setTogglePopupFlag(g, g.showParameters))
	{
		ft->showComponentInRootPopup(s, b, {12, 24});
	}
	
	return true;
}

bool DspNetworkGraph::Actions::undo(DspNetworkGraph& g)
{
	if (auto um = g.network->getUndoManager())
		return um->undo();

	return false;
}

bool DspNetworkGraph::Actions::redo(DspNetworkGraph& g)
{
	if (auto um = g.network->getUndoManager())
		return um->redo();

	return false;
}


int DspNetworkGraph::Actions::addBookMark(DspNetwork* network)
{
	auto name = PresetHandler::getCustomName("Bookmark", "Enter the name for the bookmark");

	if (name.isEmpty())
		return -1;

	auto um = network->getUndoManager();
	auto bms = network->getValueTree().getOrCreateChildWithName(PropertyIds::Bookmarks, um);

	StringArray sa;

	for (auto n : network->getSelection())
	{
		sa.add(n->getId());
	}

	auto bValue = sa.joinIntoString(";");

	for (auto b : bms)
	{
		if (b[PropertyIds::ID].toString() == name)
		{
			b.setProperty(PropertyIds::Value, bValue, um);
            return bms.indexOf(b);
		}
	}

	ValueTree bm(PropertyIds::Bookmark);
	bm.setProperty(PropertyIds::ID, name, nullptr);
	bm.setProperty(PropertyIds::Value, bValue, nullptr);
	bms.addChild(bm, -1, nullptr);

    return bms.getNumChildren() - 1;
}

bool DspNetworkGraph::Actions::zoomIn(DspNetworkGraph& g)
{
	return g.findParentComponentOfClass<ZoomableViewport>()->changeZoom(true);
}

bool DspNetworkGraph::Actions::zoomOut(DspNetworkGraph& g)
{
	return g.findParentComponentOfClass<ZoomableViewport>()->changeZoom(false);
}

bool DspNetworkGraph::Actions::zoomFit(DspNetworkGraph& g)
{
	g.findParentComponentOfClass<ZoomableViewport>()->makeSwapSnapshot(JUCE_LIVE_CONSTANT_OFF(0.998f));

	for (auto& n : g.network->getListOfNodesWithType<NodeBase>(false))
		n->setValueTreeProperty(PropertyIds::Folded, false);

	auto f = [&g]()
	{
		g.findParentComponentOfClass<ZoomableViewport>()->clearSwapSnapshot();

		auto b = g.root->getBoundsInParent();

		if(!g.isShowingRootNode())
			b = g.getLocalBounds();

		g.findParentComponentOfClass<ZoomableViewport>()->zoomToRectangle(b.expanded(UIValues::NodeMargin*2));
		g.repaint();
		g.grabKeyboardFocus();
	};

	Timer::callAfterDelay(JUCE_LIVE_CONSTANT_OFF(400), f);

	return true;
}

juce::Identifier NetworkPanel::getProcessorTypeId() const
{
	return JavascriptProcessor::getConnectorId();
}

juce::Component* NetworkPanel::createContentComponent(int index)
{
	if (auto holder = dynamic_cast<DspNetwork::Holder*>(getConnectedProcessor()))
	{
		auto sa = holder->getIdList();

		auto id = sa[index];

		if (id.isNotEmpty())
		{
			auto network = holder->getOrCreate(id);
			return createComponentForNetwork(network);
		}
	}

	return createEmptyComponent();
}

void NetworkPanel::fillModuleList(StringArray& moduleList)
{
	fillModuleListWithType<ProcessorWithScriptingContent>(moduleList);
}

void NetworkPanel::fillIndexList(StringArray& sa)
{
	if (auto holder = dynamic_cast<DspNetwork::Holder*>(getConnectedProcessor()))
	{
		auto sa2 = holder->getIdList();

		sa.clear();
		sa.addArray(sa2);
	}
}

void KeyboardPopup::addNodeAndClose(String path)
{
	bool pc = parentIsViewport;

	std::function<void(Component*)> cleanup = [pc](Component* c)
	{
#if USE_BACKEND
		if(pc)
			c->findParentComponentOfClass<ZoomableViewport>()->setCurrentModalWindow(nullptr, {});
		else
			c->findParentComponentOfClass<BackendRootWindow>()->clearModalComponent();
#endif
	};

	auto container = node.get();
	auto ap = addPosition;

	Component::SafePointer<Component> safeThis(this);

	if (path.startsWith("ScriptNode"))
	{
		auto f = [container, ap, cleanup, safeThis]()
		{
			auto clipboard = SystemClipboard::getTextFromClipboard();
			auto data = clipboard.fromFirstOccurrenceOf("ScriptNode", false, false);
			auto newTree = ValueTreeConverters::convertBase64ToValueTree(data, true);

			if (newTree.isValid())
			{
				var newNode;
				auto network = container->getRootNetwork();

				Array<DspNetwork::IdChange> changes;
				newTree = network->cloneValueTreeWithNewIds(newTree, changes, false);

				for(auto& c: changes)
		            network->changeNodeId(newTree, c.oldId, c.newId, nullptr);

				BACKEND_ONLY(DuplicateHelpers::removeOutsideConnections(newTree, changes));

				newNode = network->createFromValueTree(true, newTree, true);
				
				auto as = dynamic_cast<AssignableObject*>(container);
				as->assign(ap, newNode);

				network->deselectAll();
				network->addToSelection(dynamic_cast<NodeBase*>(newNode.getObject()), ModifierKeys());
				network->runPostInitFunctions();
			}

			if(safeThis != nullptr)
				cleanup(safeThis.getComponent());
		};

		MessageManager::callAsync(f);
	}
	else
	{
		
		auto f = [path, container, ap, cleanup, safeThis]()
		{
			if (path.isNotEmpty())
			{
				var newNode;

				auto network = container->getRootNetwork();

				newNode = network->get(path);

				if (!newNode.isObject())
					newNode = network->create(path, {});

				auto as = dynamic_cast<AssignableObject*>(container);

				as->assign(ap, newNode);

				network->deselectAll();
				network->addToSelection(dynamic_cast<NodeBase*>(newNode.getObject()), ModifierKeys());
			}

			if(safeThis != nullptr)
				cleanup(safeThis.getComponent());;
		};

		MessageManager::callAsync(f);
	}




}


juce::Rectangle<float> KeyboardPopup::getPreviewBounds()
{
	auto b = viewport.getBoundsInParent().withX(getWidth() / 2).reduced(UIValues::NodeMargin).toFloat();
	b.removeFromBottom(32.0f);
	return b;
}

void KeyboardPopup::paint(Graphics& g)
{
	static const unsigned char searchIcon[] = { 110, 109, 0, 0, 144, 68, 0, 0, 48, 68, 98, 7, 31, 145, 68, 198, 170, 109, 68, 78, 223, 103, 68, 148, 132, 146, 68, 85, 107, 42, 68, 146, 2, 144, 68, 98, 54, 145, 219, 67, 43, 90, 143, 68, 66, 59, 103, 67, 117, 24, 100, 68, 78, 46, 128, 67, 210, 164, 39, 68, 98, 93, 50, 134, 67, 113, 58, 216, 67, 120, 192, 249, 67, 83, 151,
			103, 67, 206, 99, 56, 68, 244, 59, 128, 67, 98, 72, 209, 112, 68, 66, 60, 134, 67, 254, 238, 144, 68, 83, 128, 238, 67, 0, 0, 144, 68, 0, 0, 48, 68, 99, 109, 0, 0, 208, 68, 0, 0, 0, 195, 98, 14, 229, 208, 68, 70, 27, 117, 195, 211, 63, 187, 68, 146, 218, 151, 195, 167, 38, 179, 68, 23, 8, 77, 195, 98, 36, 92, 165, 68, 187, 58,
			191, 194, 127, 164, 151, 68, 251, 78, 102, 65, 0, 224, 137, 68, 0, 0, 248, 66, 98, 186, 89, 77, 68, 68, 20, 162, 194, 42, 153, 195, 67, 58, 106, 186, 193, 135, 70, 41, 67, 157, 224, 115, 67, 98, 13, 96, 218, 193, 104, 81, 235, 67, 243, 198, 99, 194, 8, 94, 78, 68, 70, 137, 213, 66, 112, 211, 134, 68, 98, 109, 211, 138, 67,
			218, 42, 170, 68, 245, 147, 37, 68, 128, 215, 185, 68, 117, 185, 113, 68, 28, 189, 169, 68, 98, 116, 250, 155, 68, 237, 26, 156, 68, 181, 145, 179, 68, 76, 44, 108, 68, 16, 184, 175, 68, 102, 10, 33, 68, 98, 249, 118, 174, 68, 137, 199, 2, 68, 156, 78, 169, 68, 210, 27, 202, 67, 0, 128, 160, 68, 0, 128, 152, 67, 98, 163,
			95, 175, 68, 72, 52, 56, 67, 78, 185, 190, 68, 124, 190, 133, 66, 147, 74, 205, 68, 52, 157, 96, 194, 98, 192, 27, 207, 68, 217, 22, 154, 194, 59, 9, 208, 68, 237, 54, 205, 194, 0, 0, 208, 68, 0, 0, 0, 195, 99, 101, 0, 0 };

	Path path;
	path.loadPathFromData(searchIcon, sizeof(searchIcon));
	path.applyTransform(AffineTransform::rotation(float_Pi));
	path.scaleToFit(6.0f, 6.0f, 20.0f, 20.0f, true);

	g.setColour(Colours::white.withAlpha(0.8f));
	g.fillPath(path);

	auto b = getPreviewBounds().toFloat();

	if (screenshot.isValid())
	{
		g.drawImage(screenshot, b, Justification::centred);
	}
	else
	{
		g.setColour(Colours::black.withAlpha(0.05f));
		g.fillRoundedRectangle(b.reduced(3.0f), UIValues::NodeMargin);
		g.setFont(GLOBAL_BOLD_FONT());
		g.setColour(Colours::white.withAlpha(0.3f));
		g.drawText("Nothing selected", b, Justification::centred);
	}
}

bool KeyboardPopup::keyPressed(const KeyPress& k, Component*)
{
	if (k == KeyPress::F1Key)
	{
		buttonClicked(&helpButton);
		return true;
	}
	if (k == KeyPress::escapeKey)
	{
		addNodeAndClose({});
	}
	if (k == KeyPress::upKey)
	{
		auto pos = list.selectNext(false);
		scrollToMakeVisible(pos);
		nodeEditor.setText(list.getCurrentText(), dontSendNotification);
		return true;
	}
	else if (k == KeyPress::downKey)
	{
		auto pos = list.selectNext(true);
		scrollToMakeVisible(pos);
		nodeEditor.setText(list.getCurrentText(), dontSendNotification);
		return true;
	}
	else if (k == KeyPress::returnKey)
	{
		addNodeAndClose(list.getTextToInsert());
		return true;
	}

	return false;
}

KeyboardPopup::PopupList::Item::Item(const Entry& entry_, bool isSelected_) :
	entry(entry_),
	selected(isSelected_),
	deleteButton("delete", this, f)
{
	setRepaintsOnMouseActivity(true);

	if (entry.t == ExistingNode)
		addAndMakeVisible(deleteButton);

	static const StringArray icons = { "clipboard", "oldnode", "newnode" };

	p = f.createPath(icons[(int)entry.t]);
    
    setWantsKeyboardFocus(true);
}

void KeyboardPopup::PopupList::Item::buttonClicked(Button*)
{
	auto plist = findParentComponentOfClass<PopupList>();

	plist->network->deleteIfUnused(entry.insertString);

	MessageManager::callAsync([plist]()
	{
		plist->rebuildItems();
	});
}

void KeyboardPopup::PopupList::Item::mouseDown(const MouseEvent&)
{
	findParentComponentOfClass<PopupList>()->setSelected(this, false);
}

void KeyboardPopup::PopupList::Item::mouseDoubleClick(const MouseEvent& event)
{
	if (!event.mouseWasDraggedSinceMouseDown())
	{
		findParentComponentOfClass<KeyboardPopup>()->addNodeAndClose(entry.insertString);
	}
}

bool KeyboardPopup::PopupList::Item::keyPressed(const KeyPress& k)
{
	if(k == KeyPress::F1Key)
	{
		return findParentComponentOfClass<KeyboardPopup>()->keyPressed(k, this);
	}
    if(k == KeyPress::upKey)
    {
        findParentComponentOfClass<PopupList>()->selectNext(false);
        return true;
    }
    if(k == KeyPress::downKey)
    {
        findParentComponentOfClass<PopupList>()->selectNext(true);
        return true;
    }
    if(k == KeyPress::returnKey)
    {
        auto list = findParentComponentOfClass<PopupList>();
        findParentComponentOfClass<KeyboardPopup>()->addNodeAndClose(list->getTextToInsert());
        return true;
    }
    
    return false;
}



void KeyboardPopup::PopupList::Item::paint(Graphics& g)
{
	float alpha = 0.0f;

	if (isMouseOver(true))
		alpha += 0.02f;

	if (isMouseButtonDown(true))
		alpha += 0.05f;


	if (selected)
		alpha += 0.06f;

	if(alpha != 0.0f)
	{
		g.setColour(Colours::white.withAlpha(alpha));
		g.fillRoundedRectangle(getLocalBounds().toFloat(), getHeight() / 2);
	}

	auto b = getLocalBounds().toFloat();

	auto icon = b.removeFromLeft(b.getHeight());

	PathFactory::scalePath(p, icon.reduced(6.0f));

	b.removeFromLeft(10.0f);

	g.setFont(GLOBAL_BOLD_FONT());
	g.setColour(Colours::white.withAlpha(selected ? 1.0f : 0.7f));
	g.drawText(entry.displayName, b.reduced(3.0f), Justification::centredLeft);

	g.setColour(Colours::white.withAlpha(selected ? 0.6f : 0.3f));
	g.fillPath(p);
}

void KeyboardPopup::PopupList::Item::resized()
{
	deleteButton.setBounds(getLocalBounds().removeFromRight(getHeight()).reduced(3));
}



DspNetworkGraph::WrapperWithMenuBar::WrapperWithMenuBar(DspNetworkGraph* g) :
	WrapperWithMenuBarBase(g),
	n(g->network.get())
{
	rebuildAfterContentChange();
}

void DspNetworkGraph::WrapperWithMenuBar::rebuildAfterContentChange()
{
	n = dynamic_cast<DspNetworkGraph*>(canvas.getContentComponent())->network.get();

	jassert(n != nullptr);

	auto id = n->getId();

    //addButton("debug");
    
	if(n->canBeFrozen())
		addButton("export");

	addButton("zoom");

	addBookmarkComboBox();

	addSpacer(10);

	addButton("foldunselected");
	addButton("swap-orientation");

	addSpacer(10);

	addButton("error");
	addButton("cable");
	addButton("probe");
    addButton("signal");
	addButton("parameters");
	addButton("comment");
	addSpacer(10);
	addButton("wrap");
	addButton("colour");
	addButton("profile");

	addSpacer(10);

	addButton("lock");

	addSpacer(10);
	addButton("undo");
	addButton("redo");
	addSpacer(10);
    addButton("save");
    addButton("eject");
    addSpacer(10);
	
    addButton("properties");
}

void DspNetworkGraph::WrapperWithMenuBar::bookmarkUpdated(const StringArray& idsToShow)
{
	n->deselectAll();

	NodeBase::List newSelection;

	for (const auto& s : idsToShow)
	{
		auto nv = n->get(s);

		if (auto no = dynamic_cast<NodeBase*>(nv.getObject()))
			n->addToSelection(no, ModifierKeys::shiftModifier);
	}

	Actions::foldUnselectedNodes(*canvas.getContent<DspNetworkGraph>());
}

void DspNetworkGraph::WrapperWithMenuBar::addButton(const String& name)
{
	auto p = canvas.getContent<DspNetworkGraph>();

	ActionButton* b = new ActionButton(p, name);

	if (name == "probe")
	{
		b->actionFunction = Actions::toggleProbe;
		b->stateFunction = [](DspNetworkGraph& g) { return g.probeSelectionEnabled; };
		b->setTooltip("Enable parameter list selection");
	}

    if(name == "save")
    {
        b->actionFunction = Actions::save;
    }
    if(name == "signal")
    {
        b->actionFunction = Actions::toggleSignalDisplay;
        b->stateFunction = [](DspNetworkGraph& g) { return g.network->isSignalDisplayEnabled(); };
        b->setTooltip("Display the signal flow in the cables");
    }
    
    if(name == "export")
    {
        b->actionFunction = Actions::exportAsSnippet;
        b->setTooltip("Export the node and all references SNEX files as snippet");
    }
	if (name == "parameters")
	{
		b->actionFunction = Actions::showParameterPopup;
		b->setTooltip("Show all parameters in a popup");
	}

	if(name == "lock")
	{
		b->actionFunction = Actions::lockContainer;
		b->setTooltip("Locks the current container");
		b->enabledFunction = [](DspNetworkGraph& g)
		{
			auto s = g.network->getSelection();
			return !s.isEmpty() && dynamic_cast<NodeContainer*>(s.getFirst().get()) != nullptr;
		};

		b->stateFunction = [](DspNetworkGraph& g)
		{
			auto s = g.network->getSelection();
			return !s.isEmpty() && (bool)s.getFirst()->getValueTree()[PropertyIds::Locked];
		};
	}

    if(name == "eject")
    {
        b->actionFunction = Actions::eject;
        b->setTooltip("Unload this Network");
    }
    
	if (name == "colour")
	{
		b->actionFunction = Actions::setRandomColour;
		b->enabledFunction = selectionEmpty;
		b->setTooltip("Randomize colours for selection");
	}
	if (name == "cable")
	{
		b->actionFunction = Actions::toggleCableDisplay;
		b->stateFunction = [](DspNetworkGraph& g) { return g.showCables; };
		b->setTooltip("Show / Hide cables [C]");
	}
	if(name == "comment")
	{
		b->actionFunction = Actions::toggleComments;
		b->stateFunction = [](DspNetworkGraph& g) { return (bool)g.dataReference[PropertyIds::ShowComments]; };
		b->setTooltip("Show / Hide comments");
	}
	if (name == "export")
	{
		b->actionFunction = Actions::toggleFreeze;
		b->enabledFunction = [](DspNetworkGraph& g) 
		{
			auto s = g.network->getSelection();

			if (s.isEmpty())
				return g.network->canBeFrozen();
			else
			{
				if (auto fn = s.getFirst()->getEmbeddedNetwork())
					return fn->canBeFrozen();

				return false;
			}
		};

		b->stateFunction = [](DspNetworkGraph& g)
		{
			auto s = g.network->getSelection();

			if (s.isEmpty())
				return g.network->isFrozen();
			else
			{
				if (auto fn = s.getFirst()->getEmbeddedNetwork())
					return fn->isFrozen();

				return false;
			}
		};
	}
	if (name == "swap-orientation")
	{
		b->actionFunction = Actions::swapOrientation;
		b->enabledFunction = selectionEmpty;
		b->setTooltip("Swap the orientation of the selected containers");
	}
	if (name == "profile")
	{
		b->actionFunction = Actions::toggleCpuProfiling;
		b->stateFunction = [](DspNetworkGraph& g) { return g.network->getCpuProfileFlag(); };
		b->setTooltip("Activate CPU profiling");
	}
	if (name == "debug")
	{
		b->actionFunction = Actions::toggleDebug;
		b->stateFunction = [](DspNetworkGraph& g) { return g.network->isBeingDebugged(); };
		b->setTooltip("Debug this network");
	}
	if (name == "add")
	{
		b->actionFunction = [](DspNetworkGraph& g)
		{
			Actions::showKeyboardPopup(g, KeyboardPopup::New);
			return true;
		};

		b->enabledFunction = selectionEmpty;
		b->setTooltip("Create node after selection [N]");
	}
	if (name == "wrap")
	{
		b->enabledFunction = selectionEmpty;

		b->actionFunction = [](DspNetworkGraph& g)
		{
			PopupLookAndFeel plaf;
			PopupMenu m;
			m.setLookAndFeel(&plaf);

			auto s = g.network->getSelection().getFirst();

			m.addItem((int)NodeComponent::MenuActions::WrapIntoDspNetwork, "Wrap into DSP Network", NodeComponent::PopupHelpers::isWrappable(s) != 0);

			m.addItem((int)NodeComponent::MenuActions::WrapIntoChain, "Wrap into chain");

			m.addItem((int)NodeComponent::MenuActions::WrapIntoFrame, "Wrap into frame processing container");

			m.addItem((int)NodeComponent::MenuActions::WrapIntoMulti, "Wrap into multichannel container");

			m.addItem((int)NodeComponent::MenuActions::WrapIntoSplit, "Wrap into split container");

			m.addItem((int)NodeComponent::MenuActions::WrapIntoFix32, "Wrap into fix32 container");
			m.addItem((int)NodeComponent::MenuActions::WrapIntoCloneChain, "Wrap into clone container");
			m.addItem((int)NodeComponent::MenuActions::WrapIntoMidiChain, "Wrap into midichain container");
			m.addItem((int)NodeComponent::MenuActions::WrapIntoNoMidiChain, "Wrap into nomidi container");
			m.addItem((int)NodeComponent::MenuActions::WrapIntoSoftBypass, "Wrap into soft bypass container");
			m.addItem((int)NodeComponent::MenuActions::WrapIntoOversample4, "Wrap into 4x oversample container");

			m.addItem((int)NodeComponent::MenuActions::UnfreezeNode, "Explode DSP Network", s != nullptr && s->getEmbeddedNetwork() != nullptr);
			m.addItem((int)NodeComponent::MenuActions::ExplodeLocalCables, "Replace local cable connections");

			int result = m.show();

			Array<NodeComponent*> list;

			fillChildComponentList(list, &g);

			for (auto n : list)
			{
				if (n->isSelected())
				{
					n->handlePopupMenuResult(result);
					return true;
				}
			}

			return true;
		};
	}
	if (name == "error")
	{
		b->stateFunction = [](DspNetworkGraph& g)
		{
			return !g.network->getExceptionHandler().isOk();
		};

		b->setColour(TextButton::ColourIds::buttonOnColourId, Colour(0xFFAA4444));
		b->setTooltip("Select nodes with error");

		b->enabledFunction = b->stateFunction;

		b->actionFunction = [](DspNetworkGraph& g)
		{
			auto& exceptionHandler = g.network->getExceptionHandler();
			auto list = g.network->getListOfNodesWithType<NodeBase>(false);

			g.network->deselectAll();

			for (auto& n : list)
			{
				auto e = exceptionHandler.getErrorMessage(n);

				if (e.isNotEmpty())
					g.network->addToSelection(n, ModifierKeys::commandModifier);
			}

			return true;

		};
	}
	if (name == "zoom")
	{
		b->actionFunction = Actions::zoomFit;
		b->setTooltip("Reset Zoom (Ctrl+Backspace)");
	}
	if (name == "fold")
	{
		b->actionFunction = Actions::foldSelection;
		b->stateFunction = [](DspNetworkGraph& g)
		{
			auto selection = g.network->getSelection();

			if (selection.isEmpty())
				return false;

			return (bool)selection.getFirst()->getValueTree()[PropertyIds::Folded];
		};
		b->enabledFunction = selectionEmpty;
		b->setTooltip("Fold the selected nodes [F]");
	}
	if (name == "foldunselected")
	{
		b->actionFunction = Actions::foldUnselectedNodes;
		b->enabledFunction = selectionEmpty;
		b->setTooltip("Folds all unselected nodes");
	}
	if (name == "deselect")
	{
		b->actionFunction = Actions::deselectAll;
		b->enabledFunction = selectionEmpty;
		b->setTooltip("Deselect all nodes [Esc]");
	}
	if (name == "undo")
	{
		b->actionFunction = Actions::undo;
		b->setTooltip("Undo the last action [Ctrl+Z]");
	}
	if (name == "redo")
	{
		b->actionFunction = Actions::redo;
		b->setTooltip("Redo the last action [Ctrl+Y]");
	}
	if (name == "copy")
	{
		b->actionFunction = Actions::copyToClipboard;
		b->enabledFunction = selectionEmpty;
		b->setTooltip("Copy nodes to clipboard [Ctrl+C]");
	}
	if (name == "delete")
	{
		b->actionFunction = Actions::deleteSelection;
		b->enabledFunction = selectionEmpty;
		b->setTooltip("Delete selected nodes [Del]");
	}
	if (name == "duplicate")
	{
		b->actionFunction = Actions::duplicateSelection;
		b->enabledFunction = selectionEmpty;
		b->setTooltip("Duplicate node [Ctrl+D]");
	}
	if (name == "bypass")
	{
		b->actionFunction = Actions::toggleBypass;
		b->enabledFunction = selectionEmpty;

		b->stateFunction = [](DspNetworkGraph& g)
		{
			if (auto f = g.network->getSelection().getFirst())
			{
				return !f->isBypassed();
			}

			return false;
		};

		b->setTooltip("Bypass the selected nodes");
	}
	if (name == "properties")
	{
		b->setTooltip("Show node properties [P]");
		b->actionFunction = Actions::editNodeProperty;
	}
	if (name == "goto")
	{
		b->enabledFunction = selectionEmpty;

		b->actionFunction = [](DspNetworkGraph& g)
		{
			if (auto fn = g.network->getSelection().getFirst())
			{
				if (!fn->isBodyShown())
				{
					auto p = fn;

					while (p != nullptr)
					{
						p->setValueTreeProperty(PropertyIds::Folded, false);
						p = p->getParentNode();
					}
				}

				Actions::selectAndScrollToNode(g, fn);
			}

			return true;
		};
	}

	actionButtons.add(b);
	addAndMakeVisible(b);
}

void KeyboardPopup::TagList::Tag::paint(Graphics& g)
{
	auto& tl = findParentComponentOfClass<TagList>()->tags;

	auto i = tl.indexOf(this);

	auto c = MultiOutputDragSource::getFadeColour(i, tl.size()).withAlpha(1.0f);

	auto area = getLocalBounds().toFloat().reduced(2.0f);

	g.setColour(c);

	if (active)
	{
		g.fillRoundedRectangle(area, area.getHeight() / 2.0f);
		g.setColour(Colours::black);
	}
	else
	{
		g.setColour(c.withAlpha(0.7f));
		g.drawRoundedRectangle(area, area.getHeight() / 2.0f, JUCE_LIVE_CONSTANT_OFF(1.5f));
	}

	g.setFont(GLOBAL_BOLD_FONT());
	g.drawText(getName(), getLocalBounds().toFloat(), Justification::centred);
}

void KeyboardPopup::PopupList::setSelected(Item* i, bool forceRebuild)
{
	auto newIndex = items.indexOf(i);

	if (newIndex != selectedIndex || forceRebuild)
	{
		selectedIndex = newIndex;

		auto kp = findParentComponentOfClass<KeyboardPopup>();

		if (i != nullptr)
		{
			kp->currentPreview = new ImagePreviewCreator(*kp, i->entry.displayName);

			kp->oneLiner = new OneLiner();

			if (kp->currentPreview->createdNode != nullptr)
				kp->oneLiner->description = kp->currentPreview->createdNode->getNodeDescription();

			kp->addAndMakeVisible(kp->oneLiner);
			kp->resized();

			Component::SafePointer<PopupList> safeThis(this);

			MessageManager::callAsync([safeThis]()
				{
					if (safeThis.getComponent() != nullptr)
						safeThis.getComponent()->resized();
				});
		}
		else
		{
			kp->currentPreview = nullptr;
			kp->screenshot = {};
			kp->repaint();
		}

		int idx = 0;

		for (auto item : items)
		{
			item->selected = idx++ == selectedIndex;
			item->repaint();
		}
	}
}

KeyboardPopup::ImagePreviewCreator::ImagePreviewCreator(KeyboardPopup& kp_, const String& path_):
	kp(kp_),
	network(kp.network),
	path(path_)
{
	if (path.contains("."))
	{
		if (!path.startsWith("project"))
		{
			DspNetwork::AnonymousNodeCloner an(*network, &holder);

			createdNode = dynamic_cast<NodeBase*>(network->create(path, path.fromFirstOccurrenceOf(".", false, false)).getObject());
			network->getExceptionHandler().removeError(createdNode);

			for (auto p: NodeBase::ParameterIterator(*createdNode))
			{
				auto nr = RangeHelpers::getDoubleRange(p->data);
				auto v = nr.convertFrom0to1(Random::getSystemRandom().nextDouble(), false);
				p->setValueSync(v);
			}
		}
	}
	else
	{
		createdNode = dynamic_cast<NodeBase*>(network->get(path).getObject());
	}

	if (createdNode != nullptr)
	{
		createdComponent = createdNode->createComponent();
		auto r = createdNode->getPositionInCanvas({ 0, 0 });
		createdComponent->setBounds(r);

		startTimer(60);
	}
}

KeyboardPopup::ImagePreviewCreator::~ImagePreviewCreator()
{
	createdComponent = nullptr;
	holder.nodes.clear();
	holder.root = nullptr;
}

void KeyboardPopup::ImagePreviewCreator::timerCallback()
{
	auto pb = kp.getPreviewBounds();

	auto h = kp.findParentComponentOfClass<ZoomableViewport>();
	auto b = h->getLocalArea(&kp, pb.toNearestInt());
	auto srw = (float)createdComponent->getWidth() / ((float)b.getWidth());
	auto srh = (float)createdComponent->getHeight() / ((float)b.getHeight());

	auto sr = jmax(srw, srh);

	if (path.contains("."))
	{
		auto& tl = kp.tagList.tags;
		auto factoryId = path.upToFirstOccurrenceOf(".", false, false);
		Colour c = Colours::transparentBlack;

		for (auto t : tl)
		{
			if (t->getName() == factoryId)
			{
				auto i = tl.indexOf(t);
				c = MultiOutputDragSource::getFadeColour(i, tl.size()).withAlpha(1.0f);
				c = c.withMultipliedBrightness(0.6f);
				break;
			}
		}

		dynamic_cast<NodeComponent*>(createdComponent.get())->header.colour = c;
	}

	kp.screenshot = createdComponent->createComponentSnapshot(createdComponent->getLocalBounds(), true, 1.0f / sr);
	kp.repaint();

    createdComponent = nullptr;
	stopTimer();
}

}
