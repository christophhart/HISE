![](snex.png)

Version: 1.0 alpha

# Scriptnode Expression Language

The Scriptnode Expression Language (**SNEX**) is a simplified subset of the C language family and is used throughout scriptnode for customization behaviour.

- **fast**. The assembly code generated by the compiler should (more or less) match the performance of C++ compiled code. 
- **easy to use**. The syntax can be adapted within minutes for people who know C++ and / or Javascript.
- **safe** - it's impossible to crash the application. Every call that could lead to a access violation is wrapped into a safe check

It's intended use is fast execution of expressions for signal processing algorithms. Unlike the HiseScript language, which is interpreted, the scriptnode expressions are JIT compiled and run in almost native speed (several orders of magnitude above HiseScript performance). When the scriptnode graph is exported as Cpp code, the expressions will be then compiled by the standard compiler (which is why it needs to be a strict subset of C / C++).

The JIT compiler uses the awesome `asmjit` library to emit the assembly instructions. Currently supported are macOS / Windows / Linux (32bit / 64bit). iOS support is not possible due to the security restriction that prevents allocation of executable memory.

There are two places where it can be used: in the `core.jit` node, which allows creating fully customizable nodes and at the connection between parameters (or modulation sources) via the `Expression` property which can be used to convert the value send to the connection target.

## Getting started

The easiest way to get to know the language is to use the SNEX Playground which offers you a JIT compiler, a code editor with a predefined snippet and shows the assembly output that is fed directly to the CPU. It also uses the same callbacks as the `core.jit` node and offers various test signals that you can use to check your algorithm.

### Callbacks

The SNEX code will be compiled to functions that are executed on certain events (similar to HiseScript). There are four callback types:

#### The `prepare()` callback

```cpp
void prepare(double samplerate, int blocksize, int numChannels)
```

The `prepare` callback will be executed when the node is initialised or when some of the processing specifications (samplerate, blocksize or channel amount) change. You should use this function to setup your variables according to the specifications - calculate frequency coefficients etc.

#### The `reset()` callback.

```cpp
void reset()
```

The `reset()` callback will be called whenever the processing pipeline needs to be resetted. This may occur under various circumstances and should be as fast as possible (unlike the prepare callback which happens very rarely):

- when a voice is started
- when the node is unbypassed
- after the `prepare` function was called

You should use this function to clear any state variable (eg. last values or counters for oscillators).

#### The `setX` callbacks

```cpp
void setX(double newValue)
```

Whenever you want to change a parameter from the outside, you can write a function that starts with `set`and it will automatically create a scriptnode parameter with the same name (so `setGain` will create a parameter called **Gain**)

#### The `processX` callbacks

These callbacks will be executed to calculate the audio signal. There are three different callbacks available, each one will be more suitable than the others for certain types of applications.

```cpp
// channel processing: one block of audio data at the time
void processChannel(block input, int numChannel)

// Monophonic (or stateless multichannel) processing: One sample in, one sample out
float processSample(float input)

// frame-based processing: all samples of every channel at the time
void processFrame(block frame)
```

The decision which callback you want to use depends on the algorithm: for stereo-effects, the interleaved processing of the `processFrame` callback is most suitable, but is slower than the `processSample` or the `processChannel` callbacks, which should be preferred for monophonic signal calculation.

> Be aware that if the `core.jit` node is wrapped in a `framex_block` node, the `processFrame` node will yield the best performance because it directly maps to the functionality of the surrounding container.

The `core.jit` node will pick the best function for the given context: block based processing or frame-based processing by wrapping it into a `framex_block` container node.

**Block based processing**: This is the default and means that the stream of audio samples is divided into chunks with a fixed length. In this case the functions are chosen in this order:

1. `processChannel()`
2. `processFrame()`
3. `processSample()`

The `processFrame` method will be always be prioritised over the `processSample` method because once you define it, it's highly likely that you want to perform some kind of interleaved algorithm.

The fastest operation mode is of course using the `processChannel` method with a `loop_block` iterator, however using the `processFrame` method should be equally fast as using a `framex_block` method.

**Frame based processing**: Some DSP algorithms need to have all samples of each channel available at the same time. The simplest example would be a stereo-to mono converter, which just add the channels:

```cpp
l = l + r;
r = l;
```

This is known as interleaved (or frame-based) processing and can be achieved by wrapping any node into a `framex_block` container. In this case, the callbacks will be chosen in this order:

1. `processFrame()`
2. `processSample()`
3. `processChannel()`

Be aware that while the `processChannel` function is still used as last resort, it yields the worst performance, since it will create a buffer with the length 1 for each sample in each channel and then call the function.

The `core.jit` node will show which `processX` function is currently in use (along with the CPU usage), so you can compare the performances.

## Language Reference

This is the complete language reference. Features that deviate from C / Cpp are **emphasized**

The **SNEX** syntax uses brackets for blocks and semicolons for statements. Comment lines start with `//`, multiline comments with `/** Comment */)`

```cpp

/** This is a 
    multiline comment
*/
{
    x; // a statement
}
```

You can define variables in any scope (function scope or global scope), however **there are no anonymous scopes**.

## Language structure

A valid SNEX code consists of definitions of variables and functions:

```cpp
// some variables
type a = something;
type b = somethingElse;
...

// function definitions
type functionName()
{
    //... function body
}
```

**There is no concept of classes or any other object oriented design principle.** 
The rationale behind this is that a SNEX compiled object is already like a class, and the scope of a 
single SNEX code does not exceed the complexity of a single C++ class.

## Variables

Variable names must be a valid identifier, and **definitions must initialise the value**:

```cpp
type variableName = initialValue;
```

You can also define constant values by prepending `const` to the definition:

```cpp
const type value = initialValue;
```

Doing so will speed up the compilation because it doesn't need to lookup the memory location.

## Functions


Function definitions have this syntax:

```cpp
ReturnType functionName(ArgumentType1 arg1, ArgumentType2 arg2)
{
   // body
}
```

Functions can be overloaded: despite having the same name, their argument amount and types can vary. However they can't differ only in the return type.

## Types

Unlike HiseScript, **SNEX** is strictly typed. **However there is a very limited set of available types**:

- `int` - Integer numbers
- `float` - single precision floating point numbers, marked with a trailing `f`: `2.012f`
- `double`- double precision floating point numbers
- `bool` - boolean values (just as intermediate type for expression results)
- `block` - a wrapper around a preallocated buffer of float numbers
- `event` - the HiseEvent

**There is no String type**. Conversion between the types is done via a C-style cast:

```cpp
// converts a float to an int
int x = (int)2.0f;
```

Type mismatches will be implicitely corrected by the compiler if possible (but it will produce a warning message so it's not recommended behaviour to just don't care about types).

## Variable visibility

**SNEX** variables are visible inside their scope (= `{...}` block) or parent scopes. The inner scope has the highest priority and override variable names is possible:

```cpp
void test()
{
    float x = 25.0f;
    
    {
        float x = 90.0f;
        Console.print(x); // 90.0f;
    }
    
    Console.print(x); // 25.0f;
}
```

However, since this is a common pitfall for bugs, it will produce a compiler warning.

## Operators

### Binary Operations

The usual binary operators are available: 

```cpp
a + b; // Add
a - b; // Subtract
a * b; // Multiply
a / b; // Divide
a % b; // Modulo

a++; // post-increment (no pre increment support!)

!a; // Logical inversion
a == b; // equality
a != b; // inequality
a > b; // greater than
a >= b; // greater or equal
// ...

```

The rules of operator precedence are similar to every other programming language on the planet. You can use parenthesis to change the order of execution:

```cpp
(a + b) * c; // = a * c + b * c
```

Logical operators are short-circuited, which means that the second branch of a `&&` operator will not be evaluated if the first branch is false:

```cpp
int f1()
{
    Console.print(52.0f);
    return 0;
}

int f2()
{
    Console.print(12.0f);
    return 0;
}

void test()
{
    int c = f1() && f2() ? 2 : 1;
    Console.print(c);
}

// Will print 52 and 1 (f2 will not be executed)
```

### Assignment

Assigning a value to a variable is done via the `=` operator. Other assignment types are supported:

```cpp
int x = 12;
x += 3; // x == 15
x /= 3 // x == 5
```

You can access elements of a `block` via the `[]` operator:

```cpp
block b;
b[12] = 12.0f;
```

**There is an out-of-bounds check that prevents read access violations** if you use an invalid array index. This comes with some performance overhead, which can be deactivated using a compiler flag.

### Ternary Operator

Simple branching inside an expression can be done via the ternary operator:

```cpp
a ? b : c
```

The false branch will not be evaluated.

### Function calls

You can call other functions using this syntax: `functionCall(parameter1, parameter2);`Be aware that forward declaring is not supported so you can't call functions before defining them:

```cpp
void f1()
{
    f2(); // won't work
}

void f1()
{
    doSomething();
}

void f3()
{
    f1(); // now you can call it
}
```

### if / else-if branching

Conditional execution of entire code blocks is possible using the `if` / `else` keywords:

```cpp
if(condition)
{
    // first case
}
else if (otherCondition)
{
    // second case
    return;
}
else
{
    // fallback code
}

// Some other code (will not be executed if otherCondition was true)
```

### Return statement

Functions that have a return type need a return statement at the end of their function body:

```cpp
void f1()
{
    // Do something
    return; // this is optional
}

int f2()
{
    return 42; // must return a int
}
```

### Block Iterator

The only control flow mechanism in **SNEX** is an iterator for a `block`:

```cpp
double uptime = 0.0;

loop_block(sample: block)
{
    sample = (float)Math.sin(uptime);
    uptime += 0.002;
}
```

This looks like a non-standard addition, however it can be resolved to valid Cpp using the macro

```cpp
#define loop_block(x) for(auto& x)
````

because the `snex::Types::block` class in Cpp supports range-based for loops.

### API classes

There are a few inbuilt API classes that offer additional helper functions.

- the `Math` class which contains a set of mathematical functions
- the `Console` class for printing a value to the console
- the `Message` class which contains methods to operate on a HiseEvent.

The syntax for calling the API functions is the same as in HiseScript: `Api.function()`.

```cpp
float x = Math.sin(2.0f);
```

> The `Math` class contains overloaded functions for `double` and `float`, so be aware of implicit casts here.


## Embedding the language

Embedding the language in a C++ project is pretty simple:

```cpp

// Create a global scope that contains global variables.
snex::jit::GlobalScope pool;

// Create a compiler that turns a String into a function pointer.
snex::jit::Compiler compiler(pool);

// The SNEX code to be parsed - Check the language reference below
juce::String code = "float member = 8.0f; float square(float input){ member = input; return input * input; }";

// Compiles and returns a object that contains the function code and slots for class variables.
if (auto obj = compiler.compileJitObject(code))
{
    // Returns a wrapper around the function with the given name
    auto f = obj["square"];
    
    // Returns a reference to the variable slot `member`
    auto ptr = obj.getVariablePtr("member");

    DBG(ptr->toFloat()); // 8.0f

    // call the function - the return type has to be passed in via template.
    // It checks that the function signature matches 
    // and the JIT function was compiled correctly.
    auto returnValue = f.call<float>(12.0f);
    
    DBG(returnValue); // 144.0f
    DBG(ptr->toFloat()); // 12.0f
}
else
{
    DBG(compiler.getErrorMessage());
}
```

## Examples

These examples show some basic DSP algorithms and how they are implemented in SNEX. In order to use it, just load the given HISE Snippets into the latest version of HISE and play around.

### Basic Sine Synthesiser

HISE automatically supports polyphony when 

```cpp
// we initialise it to a weird value, will get corrected later
double sr = 0.0;

// the counter for the signal generation
double uptime = 0.0;

// the increment value (will control the frequency)
double delta = 0.0;



void prepare(double sampleRate, int blockSize, int numChannels)
{
    // set the samplerate for the frequency calculation
    sr = sampleRate;
}

void reset()
{
    // When we start a new voice, we just need to reset the counter
    uptime = 0.0;
}

void handleEvent(event e)
{
    // get the frequency (in Hz) from the event
    const double cyclesPerSecond = e.getFrequency();

    // calculate the increment per sample
    const double cyclesPerSample = cyclesPerSecond / sr;
    
    // multiyply it with 2*PI to get the increment value
    delta = 2.0 * 3.14159265359 * cyclesPerSample;
}

void processFrame(block frame)
{
    // Calculate the signal
    frame[0] = (float)Math.sin(uptime);

    // Increment the value
    uptime += delta;

    // Copy the signal to the right channel
    frame[1] = frame[0];
}
```

```cpp
smoothed_float s = 1.0f;

void prepare(double sampleRate, int blockSize, int numChannels)
{
    s.prepare(sampleRate, 100);
}

void reset()
{
    s.clear(0.0);
}

float processSample(float input)
{
    return s.next(input);
}
```